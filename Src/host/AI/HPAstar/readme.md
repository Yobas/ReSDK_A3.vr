# HPA* Navigation System

## Общая концепция

**HPA*** (Hierarchical Pathfinding A*) - иерархическая навигационная система для AI с поддержкой 3D навигации, многоуровневых структур и динамической генерации навигационной сетки.

Система использует **региональный подход** (10×10м регионы) для оптимизации производительности и поддержки карт любого размера. Основное преимущество - возможность динамического обновления отдельных регионов без пересчета всей карты.

---

## Архитектура системы

### Модульная структура

```
HPAstar/
├── core.sqf          - Ядро: генерация сетки, A* алгоритм
├── region.sqf        - Управление регионами
├── entrance.sqf      - Переходные точки между регионами
├── update.sqf        - Динамическое обновление
└── debug.sqf         - Визуализация и тестирование
```

### Иерархия данных

```
Глобальные структуры:
├── ai_nav_regions      (HashMap)  - regionKey → region data
├── ai_nav_nodes        (HashMap)  - nodeId → node data  
└── ai_nav_adjacency    (HashMap)  - nodeId → [[neighborId, cost], ...]

Region data:
├── nodes      - Массив ID узлов в регионе
├── edges      - Связи внутри региона
└── entrances  - Переходные точки к соседним регионам

Node data:
├── pos        - Позиция узла [x, y, z]
├── region     - Ключ региона
└── neighbors  - Список соседних узлов
```

---

## Принцип работы

### Этап 1: Генерация навигационной сетки (core.sqf)

#### 1.1 Создание узлов (`ai_nav_generateRegionNodes`)

1. **Raycast сетка**: Из верхней точки вниз (300м высота) с шагом 1м
2. **Фильтрация**: Пропускается поверхность карты (только объекты)
3. **Z-сепарация**: Узлы создаются при разнице высот > 0.7м (поддержка этажей)
4. **Результат**: Массив 3D позиций узлов

```sqf
// Пример: регион 10×10м с шагом 1м = 100 точек raycast
// На выходе: ~20-60 узлов (в зависимости от геометрии)
```

#### 1.2 Построение связей между узлами

1. **Проверка дистанции**: Максимум 2м (диагональ между соседними узлами)
2. **Проверка наклона**: Угол склона < 45° (быстрая проверка через `tan`)
3. **Raycast проверка**: Нет препятствий между узлами
4. **Двунаправленные связи**: A→B и B→A сохраняются в `ai_nav_adjacency`

**Оптимизация**: Batch raycast - все проверки за один вызов `lineIntersectsSurfaces`

---

### Этап 2: Управление регионами (region.sqf)

#### 2.1 Ключ региона (`ai_nav_getRegionKey`)

```
Позиция [125.7, 238.3] → Регион "12_23"
Размер региона: 10×10м
```

#### 2.2 Сохранение региона (`ai_nav_saveRegion`)

1. Каждому узлу присваивается уникальный ID
2. Связи конвертируются из позиций в ID узлов
3. Данные сохраняются в глобальные структуры

#### 2.3 Генерация множества регионов (`ai_nav_generateRegions`)

- Генерация в радиусе от центральной точки
- Поддержка карт любого размера
- Пропуск пустых регионов

---

### Этап 3: Переходные точки (entrance.sqf)

#### 3.1 Концепция Entrance Points

**Проблема**: Регионы изолированы друг от друга.  
**Решение**: Граничные узлы, соединяющие соседние регионы.

```
Регион A          Регион B
┌────────┐        ┌────────┐
│  •   • │        │ •   •  │
│  •   •━━━━━━━━━━━━•   •  │  ← Entrance Point
│  •   • │        │ •   •  │
└────────┘        └────────┘
```

#### 3.2 Построение связей (`ai_nav_findEntrancePoints`)

1. **Фильтрация**: Выбираются только граничные узлы (в пределах 1.5м от края)
2. **8 направлений**: North, South, East, West + диагонали
3. **Raycast проверка**: Нет препятствий между граничными узлами соседних регионов
4. **Связь**: Сохраняется как обычная связь в `ai_nav_adjacency`

**Оптимизация**: Проверяются только узлы на обращенной стороне соседнего региона

---

### Этап 4: A* Pathfinding (core.sqf)

#### 4.1 Алгоритм (`ai_nav_findPathNodes`)

Классический A* с оптимизациями:

1. **Open Set**: Узлы для проверки
2. **Closed Set**: Посещенные узлы (критично для производительности!)
3. **G-Score**: Стоимость пути от старта
4. **F-Score**: G-Score + эвристика (расстояние до цели)
5. **Эвристика**: Расстояние × 1.3 (агрессивный коэффициент для скорости)

**Ключевая оптимизация**: Пропуск узлов из Closed Set → ускорение в ~10 раз

#### 4.2 Поиск пути (`ai_nav_findPath`)

1. Найти ближайшие узлы к стартовой/конечной позиции
2. Запустить A* между узлами
3. Конвертировать ID узлов в позиции

---

### Этап 5: Динамическое обновление (update.sqf)

#### 5.1 Обновление региона (`ai_nav_updateRegion`)

**Сценарий**: Изменилась геометрия (открылась дверь, разрушена стена)

```
1. ai_nav_invalidateRegion    - Удалить старые данные
2. ai_nav_generateRegionNodes - Пересоздать узлы и связи
3. ai_nav_updateRegionEntrances_fast - Обновить entrance points
```

#### 5.2 Быстрое обновление entrance points

**Проблема**: Обновление 9 регионов (текущий + 8 соседей) → 72 операции  
**Решение**: Обновлять только связи между парами регионов → 16 операций

```sqf
ai_nav_updateEntrancesBetween [regionA, regionB]
```

**Этапы**:
1. Удалить старые entrance points между регионами
2. Очистить старые связи из `ai_nav_adjacency` (O(n) через HashSet)
3. Пересоздать связи только между этими двумя регионами

**Оптимизация Spatial Partitioning**:
- Граничные узлы разбиваются на сетку 2×2м
- Проверка связей только между близкими ячейками (3×3)
- Избежание O(n²) перебора

---

## Производительность

### Типичные показатели

| Операция | Время | Примечание |
|----------|-------|------------|
| Генерация региона | 50-100ms | 100 raycast + связи |
| A* поиск пути | 5-20ms | 10-50 узлов в пути |
| Обновление региона | 100-150ms | Регенерация + entrances |
| Построение всех entrances | 200-500ms | Зависит от кол-ва регионов |

### Оптимизации

- Batch raycast (все проверки за 1 вызов)
- Быстрая проверка наклона (без векторных операций)
- Closed Set в A* (пропуск посещенных узлов)
- Агрессивная эвристика (×1.3 для скорости)
- Spatial partitioning (избежание O(n²))
- Фильтрация граничных узлов (только релевантные стороны)

---

## Визуализация

### Отладочные инструменты (debug.sqf)

```sqf
// Быстрая инициализация
[getPosASL player, 50] call ai_nav_quickInit;

// Поиск пути
private _path = [getPosASL player, _targetPos] call ai_nav_findPath;

// Тест с визуализацией
[getPosASL player, _targetPos] call ai_nav_testPath;

// Статистика
call ai_nav_getStats;
// → hashmap {regions: 25, nodes: 1234, edges: 3456}
```

### Цветовая схема

| Цвет | Элемент | Описание |
|------|---------|----------|
| Зеленый | Узлы | Навигационные точки |
| Желтый | Границы | Рамки регионов (10×10м) |
| Голубой | Связи | Внутри региона |
| Красный | Entrance | Переходы между регионами |
| Фиолетовый | Путь | Найденный маршрут |

---

## Конфигурация

```sqf
ai_nav_regionSize = 10;       // Размер региона (м)
ai_nav_gridStep = 1;          // Шаг сетки (м)
ai_nav_maxSlope = 45;         // Макс. угол склона (°)
ai_nav_raycastHeight = 300;   // Высота raycast (м)
ai_nav_minDistZ = 0.7;        // Мин. расстояние по Z (м)
```

---

## Применение

### Сценарии использования

1. **Навигация AI внутри зданий**: Многоэтажные структуры, лестницы
2. **Динамические карты**: Открывающиеся двери, разрушаемые стены
3. **Большие карты**: Регионы генерируются по требованию
4. **Подземелья и пещеры**: 3D навигация с учетом высоты

### Ограничения

- Не работает с поверхностью карты (только объекты)
- Требует raycast проверок (CPU нагрузка)
- Регионы 10×10м фиксированные (не адаптивные)

---

## API Справка

### Основные функции

| Функция | Описание |
|---------|----------|
| `ai_nav_quickInit` | Инициализация навигации в радиусе |
| `ai_nav_findPath` | Найти путь между позициями |
| `ai_nav_updateRegion` | Обновить регион после изменений |
| `ai_nav_getStats` | Получить статистику системы |
| `ai_nav_testPath` | Тест с визуализацией пути |

### Внутренние функции

**core.sqf**: Генерация, A*, поиск узлов  
**region.sqf**: Управление регионами, сохранение  
**entrance.sqf**: Построение переходных точек  
**update.sqf**: Динамическое обновление, оптимизации  
**debug.sqf**: Визуализация, логирование, тесты

---

## Теория HPA*

### Классический HPA*

1. **Preprocessing**: Разбиение карты на регионы
2. **Abstraction**: Создание абстрактного графа (entrance points)
3. **Hierarchical Search**: Поиск пути между регионами → детализация внутри регионов

### Отличия реализации

- 3D поддержка (Z-координата, этажи)
- Динамическая генерация (no preprocessing)
- Raycast-based (не требует навигационной сетки)
- Batch операции (оптимизация для Arma 3)

---

## Дополнительные материалы

- **Оригинальная статья HPA***: "Near Optimal Hierarchical Path-Finding" (Botea et al., 2004)
- **Профилирование**: Все функции содержат debug таймеры (см. `AI_NAV_DEBUG`)
- **Визуализация**: Включить `AI_NAV_DEBUG_DRAW` для отображения сетки

---

*Документация обновлена: 2025*  
*Copyright (c) 2017-2025 the ReSDK_A3 project*

