# ReSDK_A3 - Cursor Rules

## Проект
Это проект ReSDK_A3 - SDK для разработки модификации Relicta на базе Arma 3 Engine (Платформа). Проект использует язык SQF и собственную OOP систему через макросы.

## Язык программирования
- **Основной язык:** SQF (Scripting Query Format) - язык скриптов Arma 3 Engine
- **Дополнительно:** C++ (RVEngine), C# (инструменты)

## Архитектура
- **Клиент-серверная архитектура:** четкое разделение на host/ (сервер) и client/ (клиент)
- **Модульная структура:** каждый модуль независим, имеет точку входа *_init.sqf
- **OOP система:** собственная реализация через макросы (см. host/oop.hpp)
- **NOEngine:** система оптимизированной загрузки игровых объектов

## Стандарты кодирования

### Именование
- **Классы и структуры:** PascalCase (`GameObject`, `Item`, `OverlayBase`)
- **Интерфейсы:** PascalCase с префиксом `I` (`IDestructible`, `IContainer`)
- **Функции и методы:** camelCase (`getName`, `setWeight`, `canAdd`)
- **Локальные переменные:** начинаются с `_`, затем camelCase (`_item`, `_tempValue`)
- **Объявление локальных переменных**: `private _variable = value;`
- **Глобальные переменные:** префикс модуля + camelCase (`inventory_containerData`, `cprint_isserver`)
- **Макросы и константы:** UPPER_SNAKE_CASE (`PLATFORM_VERSION`, `ISDEVBUILD`)
- **Файлы классов:** PascalCase (`GameObject.sqf`)
- **Файлы функций:** snake_case или camelCase (`functions.sqf`, `client.sqf`)
- **Файлы инициализации:** суффикс `_init.sqf` (`ServerVoice_init.sqf`)

### Макросы вместо встроенных операторов
- Используй `equals(a, b)` вместо `a isEqualTo b`
- Используй `not_equals(a, b)` вместо `!a isEqualTo b`
- Используй `equalTypes(a, b)` вместо `a isEqualType b`
- Используй `not_equalTypes(a, b)` вместо `!a isEqualType b`
- Используй `isNullVar(localVar)`, `isNull(expression)` вместо `isnil'localVar'`, `isnil {expression}`
- Используй `isNullReference(obj)` вместо `isNull obj`

### Логирование
- `log(message)` - простое логирование (1 аргумент - строка)
- `logformat(formatText, values)` - логирование с форматированием (2 аргумента: строка с %1/%2 и значения)
- `warning(message)`, `warningformat(formatText, values)` - предупреждения
- `error(message)`, `errorformat(formatText, values)` - ошибки
- `trace(message)`, `traceformat(formatText, values)` - трассировка (только в DEBUG)
- **ВАЖНО:** для нескольких значений в logformat используй `arg`: `logformat("Values: %1, %2", value1 arg value2)`

### Заголовочные файлы
- `.h` - внутренние заголовочные файлы модуля (не для включения в других модулях)
- `.hpp` - публичные заголовочные файлы (макросы, константы для других модулей)
- Используй `#include "Local.h"` для внутренних хедеров
- Используй `#include <..\Module\Public.hpp>` для публичных хедеров других модулей

### OOP паттерны
- Все поля класса должны быть объявлены через `var()` в теле класса (не внутри методов)
- Используй `objParams()`, `objParams_1(_arg)`, `objParams_2(_arg1, _arg2)` для получения параметров методов
- Используй `getSelf(field)`, `setSelf(field, value)` для доступа к полям
- Используй `callSelf(method)`, `callSelfParams(method, param1 arg param2)` для вызова методов
- Используй `callFunc(obj,method)`, `callFuncParams(obj,method, param1 arg param2)` для вызова методов других объектов
- Используй `callSuper(BaseClass,method)` или `super(BaseClass, method)` для вызова метода родителя

### Структуры (struct)
- Используй `struct(StructName)` для определения структур
- Публичные члены: camelCase без подчеркивания (`def(priority) 0`)
- Приватные члены: начинаются с `_` и camelCase (`def(_allGroups) []`)
- Используй `obj getv(field)`, `obj setv(field, value)` для доступа к полям
- Используй `obj callv(method)`, `obj callp(method,param1 arg paramN)` для вызова методов

### Модульная архитектура
- Каждый модуль независим или имеет слабую зависимость
- Модуль имеет точку входа `*_init.sqf`
- Серверные модули в `host/`
- Клиентские модули в `client/`
- Общие компоненты в `host/CommonComponents/`
- Редакторные модули в `Editor/`

### Производительность
⚠️ **КРИТИЧЕСКИ ВАЖНО:** SQF примерно в 40 раз медленнее JavaScript. Оптимизация критична только в:
- Циклах и частых операциях (выполняются многократно)
- Критических путях выполнения (влияют на отзывчивость)

В некритичных местах (разовые операции, инициализация) можно жертвовать производительностью ради читаемости.

### Обработка аргументов в макросах
- Используй `arg` вместо запятой при передаче аргументов в функции внутри макросов
- Примеры: `log(format["text %1" arg var])`, `callFuncParams(obj,method,param1 arg param2)`
- Особенно важно в: `format`, `errorformat`, `traceformat`, `callFuncParams`, `callSelfParams`

### Legacy код
- В проекте есть legacy код и deprecated методы (проект с 2017 года)
- Не удаляй legacy код без необходимости (может использоваться в других частях)
- Помечай устаревшие методы комментариями `//! deprecated` или `//DEPRECATED`
- Используй макрос `OBSOLETE(funcname)` для пометки устаревших функций

## Паттерны именования методов
- **Getter:** `get` + имя свойства (`getName`, `getWeight`)
- **Setter:** `set` + имя свойства (`setWeight`, `setRadioFrequency`)
- **Проверочные:** `is`/`can` + описание (`isInWorld`, `canAdd`)
- **Обработчики событий:** `on` + название события (`onContainerOpen`, `onMoveInItem`)
- **Внутренние методы:** могут начинаться с `__` (`__handlePreInitVars__`)

## Типы данных
- Используй `null` (псевдоним `nil`) для пустых значений
- Используй `isNull(val)`, `isNullVar(var)`, `isNullReference(obj)` для проверок
- Используй `valid(ptr)`, `isValid(ptr)` для проверки валидности указателей
- Используй `vec2(x,y)`, `vec3(x,y,z)`, `vec4(x,y,w,h)` для векторов
- Используй `createHashMap` для хэш-карт
- Используй индикаторы типа `_list`, `_map` в именах глобальных коллекций (опционально, но рекомендуется)

## Документация
Полная документация находится в `Documentation/Project/`:
- `01_OVERVIEW.md` - обзор проекта
- `02_PROJECT_STRUCTURE.md` - структура проекта
- `09_CODING_STANDARDS.md` - стандарты кодирования (детально)
- `QUICK_REFERENCE.md` - быстрый справочник макросов

## Анти-паттерны (избегай)
- Глобальные переменные без префикса модуля
- Прямой доступ к внутренним полям классов (используй публичные методы)
- Создание полей динамически в конструкторе (все поля должны быть объявлены через `var()`)
- Игнорирование `objParams()` в методах классов
- Использование встроенных операторов Платформы вместо макросов

## При написании кода
1. Всегда учитывай разделение на клиент/сервер - код должен быть в правильной директории
2. Используй модульную архитектуру - код должен быть в соответствующем модуле
3. Следуй стандартам именования для всех сущностей
4. Используй макросы вместо встроенных операторов Платформы
5. Все поля классов объявляй через `var()` в теле класса
6. Используй `arg` вместо запятой в макросах с несколькими аргументами
7. Помни о производительности в критичных местах (циклы, частые операции)
8. Документируй legacy код и deprecated методы

