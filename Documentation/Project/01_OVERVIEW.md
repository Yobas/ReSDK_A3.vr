# Обзор проекта для разработчиков

## Введение

ReSDK_A3 - это комплексный набор инструментов и исходного кода для разработки игрового контента к модификации Relicta, основанной на Платформе (Arma 3 Engine). Проект включает клиентские модули, серверный код, редактор ReEditor, систему визуального программирования ReNode и утилиты для сборки и развертывания.

## Ключевые концепции

### Архитектура клиент-сервер

Проект построен на классической клиент-серверной модели:

- **Сервер (host)** - центральный узел, управляющий игровой логикой, обрабатывающий действия игроков и синхронизирующий состояние игрового мира
- **Клиент** - локальное приложение игрока, отображающее игровой контент и отправляющее действия на сервер
- Все критичные операции выполняются на сервере, клиент лишь отображает результат

> **Пример:** Когда игрок нажимает кнопку атаки на клиенте, клиент отправляет запрос на сервер. Сервер проверяет корректность, выполняет логику (вычитает здоровье), затем рассылает обновления всем клиентам.

### OOP система (Object-Oriented Programming)

Проект использует собственную систему объектно-ориентированного программирования, реализованную через макросы:

- **Классы** - определяются через макрос `class()` с наследованием через `extends()`
- **Объекты** - виртуальные объекты на основе типа `Location` в Платформе
- **Методы и поля** - определяются через макросы `func()` и `var()`
- Система полностью описана в заголовочном файле `host/oop.hpp`

### NOEngine (Net Objects Engine)

Система оптимизированной загрузки и синхронизации игровых объектов:

- Динамическая подгрузка частей карты (чанков) для каждого клиента
- Объекты существуют на сервере, но создаются локально на клиенте только в области видимости
- Репликация состояния происходит программно, а не через стандартный механизм Платформы
- Разделение объектов по типам с разной дистанцией прорисовки (Item, IStruct, Decor, BasicMob)

Это позволяет поддерживать на карте тысячи объектов без критичной потери производительности.

### Модульная архитектура

Проект разделен на независимые модули:

- **Серверные модули** (`host/`) - выполняются только на сервере
- **Клиентские модули** (`client/`) - выполняются только на клиенте
- **Общие компоненты** (`host/CommonComponents/`) - используются и на клиенте, и на сервере
- **Редакторные модули** (`Editor/`) - используются только в редакторе

Каждый модуль имеет свою точку входа (`*_init.sqf`) и четко определенные зависимости.

## Структура проекта

Основные директории:

```
Src/
├── host/          # Серверный код
├── client/        # Клиентский код
├── Editor/        # Код редактора ReEditor
├── RVEngine/      # C++ расширение (внешний компонент)
├── ReBridge/      # Редакторный модуль для C# скриптов (только для редактора)
└── Scripts/       # C# скрипты для инструментов
```

Подробнее см. [Структура проекта](02_PROJECT_STRUCTURE.md).

## Технологический стек

- **Язык**: SQF (предоставляется Платформой), C++ (RVEngine), C# (инструменты)
- **Платформа**: Arma 3 Engine (Real Virtuality Engine) - в документации обозначается как "Платформа" для единообразия
  - **Примечание о терминологии:** "Платформа" = Arma 3 Engine = Real Virtuality Engine (все это синонимы)
- **Сборка**: RBuilder (SQF), CMake (RVEngine)
- **Версионирование**: Git, семантическое версионирование

## Быстрый старт для новых разработчиков

### Что нужно знать перед началом

1. **Базовое понимание SQF** - язык программирования, предоставляемый Платформой
2. **Понимание клиент-серверной архитектуры** - как взаимодействуют клиент и сервер
3. **Опыт работы с Git** - система контроля версий
4. **Базовые навыки отладки** - умение находить и исправлять ошибки

### Рекомендуемый порядок изучения

1. ✅ Прочитайте [Руководство по установке](../INSTALL_GUIDE.md) и настройте окружение
2. ✅ Изучите [Структуру проекта](02_PROJECT_STRUCTURE.md) - понять организацию кода
3. ✅ Ознакомьтесь с [Особенностями синтаксиса](03_SYNTAX_GUIDE.md) - специфика языка проекта
4. ✅ Изучите [Модульную систему](04_MODULE_SYSTEM.md) - как создавать новые модули
5. ✅ Прочитайте [Стандарты кодирования](09_CODING_STANDARDS.md) - правила написания кода
6. ✅ Изучите [Процессы разработки](08_DEVELOPMENT_WORKFLOW.md) - workflow команды

### Первые шаги

1. **Клонируйте репозиторий** согласно [INSTALL_GUIDE.md](../INSTALL_GUIDE.md)
2. **Настройте окружение** - установите необходимые инструменты
3. **Запустите проект** - убедитесь, что всё работает локально
4. **Изучите существующий код** - начните с простых модулей
5. **Создайте свой первый модуль** - следуя [Модульной системе](04_MODULE_SYSTEM.md)

## Связь с существующей документацией

Эта проектная документация дополняет существующие руководства:

- **[API документация](../API/README.md)** - Справочник API всех модулей (генерируется автоматически)
- **[Архитектура проекта](../PROJECT_ARCHITECTURE.md)** - Общее описание архитектуры
- **[Руководство по скриптингу](../ScriptingGuides/README.md)** - Основы языка SQF
- **[Руководство по редактору](../EditorGuides/README.md)** - Использование ReEditor
- **[ReNode документация](../ReNode/README.md)** - Визуальное программирование
- **[RVEngine документация](../RVEngine/README.md)** - Документация C++ расширения (внешний компонент)

Проектная документация фокусируется на:
- **Технических деталях** реализации
- **Процессах разработки** и workflow
- **Особенностях проекта** и специфичных решениях
- **Поддержке и сопровождении** проекта

## Важные особенности проекта

### Обработка и выполнение кода

- Код проходит через препроцессор (обработка макросов, `#include`, условная компиляция) и затем загружается во время запуска игры/редактора
- Формально процесс загрузки модулей называется "компиляцией", но фактически это препроцессинг и исполнение скриптов (которые загружаются в байт-код движком Платформы)
- Используется условная компиляция через флаги: `DEBUG`, `RELEASE`, `EDITOR`, `RBUILDER`

### Производительность

**Важное примечание:** Скрипты на SQF примерно в 40 раз медленнее, чем JavaScript. Это критично важно понимать, потому что стандартные подходы, которые работают в обычных языках программирования, в SQF могут приводить к серьезным проблемам с производительностью. Всегда держите в голове, что мы пишем на медленном языке, и оптимизация критична в определенных местах.

Однако это не означает, что нужно оптимизировать весь код - производительность критически важна только в определенных местах:

- **Критичные участки:** циклы, частые операции (выполняются многократно), критические пути выполнения (влияют на отзывчивость системы)
- **Некритичные участки:** разовые операции, код инициализации, обработка редких событий - в таких местах можно жертвовать производительностью ради читаемости и простоты кода

**Где важна оптимизация:**
- NOEngine решает сетевую проблему с большим количеством объектов: глобальные объекты постоянно синхронизируются по сети, что создает нагрузку. NOEngine позволяет гибко управлять частотой обновления состояния объектов и использовать локальные объекты вместо глобальной репликации
- Оптимизация фокусируется на частых операциях и циклах, которые выполняются многократно (например, обработка каждого кадра, обновление состояния объектов, обработка сетевых пакетов)

### Совместимость

- Проект развивается с 2017 года
- В коде присутствует legacy-код и deprecated-методы, которые все еще поддерживаются

## Архитектурные решения и их обоснование

### Клиент-серверная архитектура

**Почему выбрана:**
- Обеспечивает безопасность игровой логики (все критичные операции на сервере)
- Предотвращает читерство (клиент не может влиять на игровую логику напрямую)
- Централизованное управление состоянием игрового мира
- Стандартный подход для многопользовательских игр

**Как реализовано:**
- Сервер выполняет всю игровую логику и валидацию
- Клиент отправляет действия через RPC и отображает результат
- Синхронизация состояния через NOEngine и RPC

### OOP система

**Почему выбрана:**
- Позволяет структурировать код в объектно-ориентированном стиле
- Обеспечивает инкапсуляцию и наследование
- Упрощает управление сложными игровыми объектами
- Обеспечивает единообразие кода

**Как реализовано:**
- Макросы для объявления классов, методов и полей
- Использование location объектов Платформы как основы объектов
- Система прототипов для наследования

**Ограничения:**
- SQF не поддерживает настоящий OOP, система реализована через макросы
- Производительность ниже, чем у нативных структур данных
- Требует понимания системы макросов для эффективного использования

### NOEngine (Net Objects Engine)

**Почему выбрана:**
- Стандартный механизм Платформы не справляется с большим количеством объектов
- Глобальные объекты постоянно синхронизируются по сети, создавая нагрузку
- Необходимость оптимизации сетевого трафика и производительности

**Как реализовано:**
- Динамическая подгрузка частей карты (чанков) для каждого клиента
- Локальное создание объектов только в области видимости
- Программная репликация состояния с гибким управлением частотой обновления
- Разделение объектов по типам с разной дистанцией прорисовки

**Преимущества:**
- Позволяет поддерживать тысячи объектов на карте
- Снижает сетевой трафик
- Улучшает производительность клиента

### Модульная архитектура

**Почему выбрана:**
- Разделение ответственности между модулями
- Упрощение разработки и поддержки
- Возможность независимой разработки модулей
- Четкое определение зависимостей

**Как реализовано:**
- Каждый модуль имеет точку входа (`*_init.sqf`)
- Модули регистрируются в соответствующих загрузчиках
- Четкое разделение на host/client/editor/CommonComponents

## Legacy код и deprecated методы

### Идентификация legacy кода

В проекте присутствует legacy код и deprecated методы, которые все еще поддерживаются для обратной совместимости. Проект развивается с 2017 года, поэтому некоторые старые подходы могут отличаться от современных.

**Маркеры legacy кода:**
- Комментарии `//! deprecated` или `//DEPRECATED`
- Использование макроса `OBSOLETE(funcname)` в коде
- Упоминание в коде о legacy версиях (например, "Legacy - 0.7.576 fix")
- Методы, помеченные как устаревшие в документации API

**Примеры:**
```sqf
// Использование макроса OBSOLETE
OBSOLETE(myOldFunction);  // Помечает функцию как устаревшую

// Комментарии в коде
//! DEPRECATED - не используется
// Legacy - 0.7.576 fix: после deleted ghosts...
```

### Стратегия работы с legacy кодом

**При работе с legacy кодом:**

1. **Не удаляйте legacy код без необходимости**
   - Legacy код может использоваться в других частях проекта
   - Удаление может сломать обратную совместимость

2. **Документируйте использование legacy кода**
   - Указывайте, почему используется legacy подход
   - Предлагайте альтернативы, если они существуют

3. **Мигрируйте постепенно**
   - Создавайте новые функции с современным подходом
   - Помечайте старые функции как deprecated
   - Постепенно заменяйте использование старых функций на новые

4. **Проверяйте совместимость**
   - Убедитесь, что изменения не сломают существующий функционал
   - Тестируйте код, использующий legacy функции

### Известные deprecated элементы

- **Методы GameObject:** некоторые методы помечены как deprecated (например, `onExtraAction()`, `getSectorPos()`)
- **Старые системы:** некоторые системы были переработаны, но старый код сохранен для совместимости
- **Устаревшие макросы:** некоторые макросы OOP имеют устаревшие версии (например, `callSuper()` vs `super()`)

## Известные ограничения

### Ограничения SQF

**Производительность:**
- SQF примерно в 40 раз медленнее, чем JavaScript
- Производительность критична только в местах, где она действительно решает (циклы, частые операции, критические пути)
- Оптимизация фокусируется на частых операциях и циклах

**Синтаксис:**
- Макросы - это простой текстовый реплейс (не контекстно-зависимый препроцессор)
- Запятые в макросах воспринимаются как разделители аргументов (используйте `arg`)
  - `arg` заменяется на запятую после обработки макросов, что позволяет избежать конфликтов
  - Используйте `arg` при передаче аргументов в функции внутри макросов: `format["text %1" arg var]`, `callFuncParams(obj,method,param1 arg param2)`
  - Особенно важно в макросах `format`, `errorformat`, `traceformat`, `callFuncParams`, `callSelfParams` и других, принимающих несколько аргументов
- Ограниченная поддержка современных языковых конструкций

**Типизация:**
- Слабая типизация - типы проверяются во время выполнения
- Необходимость ручной проверки типов перед использованием
- Отсутствие compile-time проверок типов

### Ограничения OOP системы

**Производительность:**
- OOP объекты медленнее, чем структуры (struct) или нативные типы
- Используйте структуры для легковесных данных, где не требуется полная функциональность классов

**Ограничения:**
- Не все возможности настоящего OOP поддерживаются
- Виртуальность методов определяется системой (не настраивается явно)
- Требует понимания системы макросов

### Ограничения структур

**Память:**
- Все значения полей одного типа располагаются по одному адресу в памяти
- Изменение массива в одном экземпляре изменит его во всех остальных
- Для независимых значений нужно инициализировать поля в `def(init)`

**Выполнение:**
- По умолчанию все методы выполняются в unscheduled окружении
- Может ограничивать использование некоторых функций Платформы

### Ограничения сетевых взаимодействий

**RPC:**
- Размер передаваемых данных напрямую влияет на загрузку сетевого канала - отсылайте как можно меньше данных
- Нет встроенной системы таймаутов
- В обычной ситуации порядок прихода RPC гарантирован, если нет проблем с сетью

**Синхронизация:**
- Сложность синхронизации состояния большого количества объектов
- Необходимость оптимизации частоты обновлений

### Ограничения сборки и деплоя

**RBuilder:**
- Препроцессинг может быть медленным для больших проектов
- Ошибки препроцессинга могут быть сложными для диагностики

**Сервис обновления:**
- Автоматическая сборка происходит при мерже и выпуске нового релиза

### Ограничения редактора

**Требования:**
- Требуется мод @EditorContent
- BattlEye должен быть отключен
- Некоторые функции доступны только в редакторе

**Производительность:**
- Редактор может быть медленным при работе с большими сценами
- 3D предпросмотр может требовать значительных ресурсов

## Ресурсы и контакты

- **GitHub репозиторий**: Основной репозиторий проекта
- **Discord**: [Discord сервер](https://discord.relicta.ru) для общения
- **Веб-сайт**: [relicta.ru](https://relicta.ru)

## Что дальше?

- ➡️ [Структура проекта](02_PROJECT_STRUCTURE.md) - детальное описание структуры
- ➡️ [Особенности синтаксиса](03_SYNTAX_GUIDE.md) - специфика синтаксиса проекта
- ➡️ [Модульная система](04_MODULE_SYSTEM.md) - создание модулей

