# Отладка и диагностика

Отладка - критически важный процесс при разработке проекта. В этом руководстве описаны инструменты и техники отладки для разных частей проекта.

## Инструменты отладки

### Встроенное логирование

Проект использует систему макросов для логирования из `engine.hpp`:

```sqf
#include "engine.hpp"

// Простое логирование
log("Сообщение");

// Логирование с форматированием
logformat("Модуль: Значение: %1", _value);

// Предупреждения
warning("Предупреждение");
warningformat("Модуль: Проблема: %1", _issue);

// Ошибки
error("Критическая ошибка");
errorformat("Модуль: Ошибка: %1", _errorMsg);

// Трассировка (только в DEBUG)
trace("Точка выполнения");
traceformat("Модуль: Данные: %1", _data);
```

### Breakpoints

Используйте макрос `breakpoint()` для установки точек останова:

```sqf
#ifdef __TRACE__ENABLED
breakpoint_setfile("MyModule.sqf");
breakpoint("Достигнута точка останова");
#endif
```

**Важно:** Breakpoints работают только при включенном флаге `__TRACE__ENABLED` (автоматически в DEBUG).

### Debug консоль

Используйте `debug_console` расширение для вывода в консоль:

```sqf
"debug_console" callExtension "message";
```

## Отладка host кода

### Логирование в RPT файлы

Серверные логи сохраняются в файлах `.rpt`:

**Расположение:**
- Windows: `%LOCALAPPDATA%\Arma 3\`
- Имя файла: `arma3server_YYYY-MM-DD_HH-MM-SS.rpt` (формат: `arma3server_x64_2025-12-21_19-05-12.rpt`)

### Отладочные макросы и флаги

Используйте флаги компиляции для отладки:

```sqf
#ifdef DEBUG
    // Код выполняется только в режиме отладки
    logformat("Debug: Значение: %1", _value);
#endif
```

### Работа с классами и объектами в отладчике

**Важно:** В debug консоли escape меню переменная `this` не существует. Макросы OOP (`getSelf`, `callSelf` и т.д.) не могут использоваться в debug консоли напрямую, так как они требуют контекста компиляции.

Для отладки объектов в debug консоли:
1. Используйте функцию переключения окна отладки (розовая кнопка в интерфейсе) для просмотра состояния цели, предмета в руке или персонажа
2. Для программной отладки используйте тестовые файлы, которые загружаются отдельно, где можно использовать макросы

**Пример для тестового файла:**
```sqf
// Этот код может быть только в отдельном тестовом файле, который загружается отдельно
// НЕ используйте макросы OOP напрямую в debug консоли

// Получение всех полей объекта (в тестовом файле)
private _obj = cursorObject; // или другой объект
private _fields = (_obj getVariable PROTOTYPE_VAR_NAME) getVariable "__allfields";

// Получение значения поля через прямую работу с Location объектом
private _value = _obj getVariable "fieldName";

// Вывод состояния объекта
logformat("Debug: Object state: %1", _fields);
```

**Для отладки через debug консоль в escape меню:**
- Используйте прямую работу с переменными Location объектов
- Проверяйте объекты через `valid()`, `isNullReference()`
- Используйте функции переключения окна отладки для визуального просмотра

#### Трассировка методов

В коде классов можно добавлять трассировку:

```sqf
func(myMethod)
{
    objParams();
    traceformat("MyClass: myMethod called with: %1", _param);
    // код метода
};
```

### Профилирование производительности

Используйте макрос `tickTime` (из `engine.hpp`) для измерения времени выполнения:

```sqf
private _startTime = tickTime;
// ваш код
private _endTime = tickTime;
private _duration = _endTime - _startTime;
logformat("Performance: Execution time: %1ms", _duration * 1000);
```

**Примечание:** `tickTime` - это макрос для `diag_tickTime`, рекомендуется использовать макрос для единообразия кода.

## Отладка client кода

### Клиентские логи

Клиентские логи также сохраняются в `.rpt` файлах:

**Расположение:**
- Windows: `%LOCALAPPDATA%\Arma 3\`
- Имя файла: `arma3_x64_YYYY-MM-DD_HH-MM-SS.rpt` (формат: `arma3_x64_2025-12-21_19-05-12.rpt`)

**Важно:** На клиенте в продакшене нет стектрейсов (stack trace), потому что код собирается в один большой файл `CLIENT` через систему сборки (`bt_buildClient`). Это делает отладку на клиенте сложнее - используйте детальное логирование.

### Отладка через ClientStatistic

Модуль `ClientStatistic` предоставляет визуальную отладку общей информации. Переключается через команду `debugvars`:

```sqf
// Включение отображения (через debug консоль или локальную команду)
debugvars 1

// Выключение
debugvars 0
```

**Что показывает:**
- FPS (текущий, минимальный, deltaTime)
- Номер кадра
- Информация о NOEngine (количество пакетов, прогресс загрузки чанков, количество объектов)
- Информация о LightEngine
- В режиме редактора/сингла: дополнительная информация об освещении

**Примеры отображаемой информации:**
- `fps: cur:60; min:55; dt:0.016`
- `NOE packets: amount 1234; packets query 5`
- `NOE progress: {"LD","LD","NON_LD"}`
- `NOE objs: [10, 15, 8]` (количество объектов по типам чанков)

**Примечание:** `ClientStatistic` показывает только общую информацию, не детали конкретных объектов.

### Синхронизация с сервером

Отлаживайте сетевые взаимодействия:

```sqf
// На клиенте - отправка RPC на сервер
#include "clientRpc.hpp"
logformat("Client: Sending RPC: %1", _data);
rpcSendToServer("myAction", [_data]);

// На сервере - регистрация обработчика
#include "serverRpc.hpp"
private _myActionHandler = {
    params ["_data"];
    logformat("Server: Received RPC: %1", _data);
};
rpcAdd("myAction", _myActionHandler);
```

### Отладка UI (WidgetSystem)

Для отладки виджетов используйте правильный синтаксис WidgetSystem. См. раздел [Работа с WidgetSystem](../Project/03_SYNTAX_GUIDE.md#работа-с-widgetsystem) для правильных примеров создания и использования виджетов.

## Отладка editor кода

### Редакторские инструменты отладки

Редактор имеет встроенные инструменты отладки:

- **Логи редактора** - отображаются в консоли редактора
- **Инспектор объектов** - просмотр состояния игровых объектов
- **Отладчик визуального скриптинга** - для ReNode

### Тестирование компонентов

```sqf
#ifdef EDITOR
componentInit(TestComponent)
    testComponent_run = {
        log("Testing component...");
        // тестовый код
    };
    
    call testComponent_run;
#endif
```

### Симуляция

Используйте симуляцию в редакторе для тестирования. Для запуска симуляции в редакторе используйте стандартные функции редактора Платформы. Подробнее о работе с редактором см. в документации редактора.

## Специфичные техники

### Отладка NOEngine (репликация объектов)

NOEngine имеет специальные отладочные флаги:

```sqf
#ifdef DEBUG
    // Отображение чанков
    #define NOE_DEBUG_SHOW_CHUNKS
    
    // Отображение объектов
    #define NOE_DEBUG_SHOW_OBJECTS
#endif
```

**Логирование репликации:**
- Логи загрузки чанков
- Логи создания объектов
- Логи синхронизации состояния

### Отладка OOP системы

#### Проверка иерархии классов

Для проверки иерархии классов используйте debug консоль в escape меню. Не логируйте все классы напрямую (их тысячи), вместо этого:

1. Используйте debug консоль для проверки переменных по индексам или диапазонам:
   ```sqf
   // В debug консоли можно проверить конкретные элементы
   (p_table_allclassnames) select 0  // Первый класс
   (p_table_allclassnames) select [0, 10]  // Первые 10 классов
   ```

2. Проверяйте наследование для конкретного класса:
   ```sqf
   // В debug консоли
   (p_table_inheritance) get "MyClass"  // Наследование для конкретного класса
   ```

**Важно:** Не пытайтесь логировать `p_table_allclassnames` или `p_table_inheritance` полностью - это вызовет проблемы с производительностью из-за большого объема данных.

#### Отладка создания объектов

```sqf
private _obj = new(MyClass);
traceformat("OOP: Created object: %1", _obj);

// Проверка типа объекта
private _className = callFunc(_obj,getClassName);
logformat("OOP: Object class: %1", _className);
```

### Отладка сетевого взаимодействия (RPC)

#### Включение RPC логирования

В `SETTINGS.h` можно включить логирование RPC в консоль:

```sqf
// В SETTINGS.h
#define ENABLE_RPCLOG_CONSOLE_SERVER  // Логи RPC на сервере в консоль
#define ENABLE_RPCLOG_CONSOLE_CLIENT  // Логи RPC на клиенте в консоль (отключается в релизе)
```

#### Трассировка RPC вызовов

Используйте логирование в коде для трассировки:

```sqf
// На клиенте - отправка RPC на сервер
#include "clientRpc.hpp"
traceformat("RPC: Sending myAction with %1", _data);
rpcSendToServer("myAction", [_data]);

// На сервере - в обработчике
#include "serverRpc.hpp"
private _myActionHandler = {
    params ["_data"];
    traceformat("RPC: Received myAction with %1", _data);
    // обработка
};
rpcAdd("myAction", _myActionHandler);
```

#### Эмуляция сетевой задержки

Для тестирования сетевых операций в режиме симуляции можно включить эмуляцию лага сети в `SETTINGS.h`:

```sqf
// В SETTINGS.h раскомментируйте:
#define ENABLE_LAG_NETWORK

// Настройки задержки (в миллисекундах):
#define __LAG_NETWORK_PING_MIN 1    // Минимальная задержка
#define __LAG_NETWORK_PING_MAX 10   // Максимальная задержка

// Для динамической настройки задержки включите:
#define __LAG_NETWORK_MANAGED_TICKTIME
// Тогда можно использовать функцию:
lagnet_setrange = {
    params [["_low",1,[0]],["_up",10,[0]]];
    LAG_NETWORK_TICKTIME_MIN = _low / 1000;
    LAG_NETWORK_TICKTIME_MAX = _up / 1000;
};

// Вызов: [5, 50] call lagnet_setrange;  // Задержка от 5 до 50 мс
```

**Примечание:** Эмуляция лага работает только в режиме симуляции (EDITOR или SP_MODE).

## Работа с логами

### Расположение логов

**Серверные логи:**
- Windows: `%LOCALAPPDATA%\Arma 3\`
- Имя файла: `arma3server_x64_YYYY-MM-DD_HH-MM-SS.rpt`

**Клиентские логи:**
- Windows: `%LOCALAPPDATA%\Arma 3\`
- Имя файла: `arma3_x64_YYYY-MM-DD_HH-MM-SS.rpt`

**Редакторские логи:**
- Те же пути, что и для клиента
- Ошибки редактора также попадают в логи

### Поиск в логах

Используйте поиск для нахождения ошибок:

**Ключевые слова для поиска:**
- `ERROR` - ошибки
- `WARNING` - предупреждения
- `TRACE` - трассировка
- Название модуля - логи конкретного модуля

**Формат логов:** Логи форматируются через систему логирования проекта. Формат зависит от настроек логирования в модуле `Logger`. Обычно логи содержат время, уровень важности и сообщение.

**Рекомендации:**
- Используйте поиск по времени для локализации проблемы
- Ищите паттерны ошибок (повторяющиеся сообщения)
- На клиенте в продакшене нет стектрейсов (код собирается в один файл), поэтому важно использовать детальное логирование

### Работа с логами продакшн-сервера

**Особенности продакшн-логов:**
- Большой объем данных требует эффективного поиска
- Логи могут быть ротированы (старые логи удаляются)
- Важно сохранять логи для анализа критичных ошибок

**Инструменты для анализа:**
- Используйте текстовые редакторы с поддержкой больших файлов
- Применяйте grep/ripgrep для поиска по паттернам
- Фильтруйте логи по времени, модулю, уровню важности

**Типичные паттерны в продакшн-логах:**
- Ошибки загрузки модулей (проверьте порядок загрузки)
- RPC ошибки (проверьте обработчики RPC)
- OOP ошибки (проверьте объекты и методы)
- Проблемы производительности (медленные операции)

**Анализ критичных ошибок:**
1. Найдите время возникновения ошибки
2. Изучите контекст перед ошибкой (что происходило)
3. На сервере проверьте стек вызовов для понимания цепочки событий
4. Ищите связанные ошибки или предупреждения

## Профилирование производительности

### Измерение времени выполнения

Используйте макрос `tickTime` (из `engine.hpp`) для измерения времени выполнения:

```sqf
private _startTime = tickTime;
// ваш код
private _endTime = tickTime;
private _duration = _endTime - _startTime;
logformat("Performance: Execution time: %1ms", _duration * 1000);
```

**Рекомендации:**
- Измеряйте только критичные операции
- Учитывайте влияние измерения на производительность
- Используйте условную компиляцию для профилирования только в DEBUG

### Профилирование циклов

Особое внимание уделяйте циклам, так как они выполняются многократно:

```sqf
private _startTime = tickTime;
{
    // операции в цикле
} forEach _largeArray;
private _duration = tickTime - _startTime;
logformat("Performance: Loop execution time: %1ms for %2 items", _duration * 1000 arg count _largeArray);
```

**Оптимизация циклов:**
- Избегайте создания объектов внутри циклов
- Кэшируйте результаты вычислений
- Используйте эффективные алгоритмы

### Профилирование сетевых операций

Для профилирования сетевых операций можно использовать эмуляцию лага (см. раздел [Эмуляция сетевой задержки](#эмуляция-сетевой-задержки)).

Также можно измерять время выполнения RPC вызовов в коде:

```sqf
#include "clientRpc.hpp"
private _startTime = tickTime;
rpcSendToServer("serverAction", [_data]);
// Ждем ответа (если синхронный вызов)
private _duration = tickTime - _startTime;
if (_duration > 1.0) then {
    warningformat("Network: RPC call took %1ms", _duration * 1000);
};
```

**Примечание:** Для асинхронных RPC вызовов измерение времени требует специальной логики с callback'ами.

### Выявление узких мест

**Типичные узкие места:**
- Создание объектов в циклах
- Неоптимальные алгоритмы поиска
- Частые сетевые запросы
- Большие операции с массивами

**Методы выявления:**
- Профилируйте код по частям
- Используйте логирование времени выполнения
- Анализируйте логи на медленные операции

**Пример измерения:**
```sqf
private _start = tickTime;
// код
private _duration = tickTime - _start;
logformat("Performance: Execution time: %1ms", _duration * 1000);
```

### Инструменты профилирования

**Встроенные инструменты:**
- `tickTime` - измерение времени (макрос для `diag_tickTime`)
- `ClientStatistic` - визуальная статистика (FPS, память, NOEngine)
- Логирование производительности

**Рекомендации:**
- Профилируйте код в условиях, близких к продакшн
- Учитывайте нагрузку при профилировании
- Сравнивайте производительность до и после оптимизаций

## Типичные проблемы

Этот раздел содержит краткий обзор типичных проблем. Подробные описания и решения см. в [Типичные проблемы и их решения](10_TROUBLESHOOTING.md).

### Runtime ошибки

- **Undefined variable** - переменная не была инициализирована
- **Cannot call (nil value)** - функция не была определена или загружена
- **Array index out of range** - попытка доступа к несуществующему индексу
- **Type mismatch** - неверный тип данных

**См. также:** [Типичные проблемы - Runtime ошибки](10_TROUBLESHOOTING.md#runtime-ошибки)

### Проблемы загрузки модулей

- **Модуль не загружается** - не зарегистрирован в загрузчике или ошибки компиляции
- **Неправильный порядок загрузки** - модуль загружается раньше зависимостей
- **Циклические зависимости** - модули зависят друг от друга циклически

**См. также:** [Типичные проблемы - Проблемы загрузки модулей](10_TROUBLESHOOTING.md#проблемы-загрузки-модулей)

### Проблемы производительности

- **Медленные операции в циклах** - дорогие операции выполняются многократно
- **Утечки памяти** - объекты не удаляются после использования
- **Слишком частые сетевые запросы** - высокая сетевая нагрузка

**См. также:** [Типичные проблемы - Проблемы производительности](10_TROUBLESHOOTING.md#проблемы-производительности)

### Отладка OOP системы

- **Объект не создается** - класс не был загружен или ошибка в конструкторе
- **Метод не вызывается** - метод не определен или неправильное использование макросов
- **Проблемы с наследованием** - неправильное использование наследования
- **Проблемы с полями объекта** - поле не было инициализировано

**См. также:** [Типичные проблемы - Отладка OOP системы](10_TROUBLESHOOTING.md#отладка-oop-системы)

### Проблемы редактора

- **Редактор не загружается** - мод @EditorContent не установлен или BattlEye включен
- **Ошибки компиляции** - синтаксические ошибки в коде редактора
- **Проблемы с визуальными компонентами** - проблемы с загрузкой моделей

**См. также:** [Типичные проблемы - Проблемы редактора](10_TROUBLESHOOTING.md#проблемы-редактора)

## Лучшие практики

### Структурированное логирование

```sqf
// Используйте префиксы для группировки (в строке)
#define LOG_PREFIX "MyModule"

log(LOG_PREFIX + ": Initializing...");  // Простое сообщение - используйте log()
logformat(LOG_PREFIX + ": Value: %1", _value);  // С форматированием - используйте logformat()
```

### Условное логирование

```sqf
#ifdef DEBUG
    #define DEBUG_LOG(msg) log("Debug: " + msg)  // Простое сообщение - используйте log()
    #define DEBUG_LOG_FORMAT(fmt,args) logformat("Debug: " + fmt, args)  // С форматированием - используйте logformat()
#else
    #define DEBUG_LOG(msg)
    #define DEBUG_LOG_FORMAT(fmt,args)
#endif

DEBUG_LOG("This only logs in DEBUG mode");
DEBUG_LOG_FORMAT("Value: %1", _value);
```

### Проверка состояний

```sqf
// Проверка валидности перед использованием
if (!valid(_obj)) exitWith {
    error("MyModule: Object is invalid");
};
```

## Что дальше?

- ➡️ [Типичные проблемы и их решения](10_TROUBLESHOOTING.md) - подробные описания проблем и решений
- ➡️ [Модульная система](04_MODULE_SYSTEM.md) - отладка модулей
- ➡️ [Быстрый справочник](QUICK_REFERENCE.md) - макросы для отладки
