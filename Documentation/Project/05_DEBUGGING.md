# Отладка и диагностика

Отладка - критически важный процесс при разработке проекта. В этом руководстве описаны инструменты и техники отладки для разных частей проекта.

## Инструменты отладки

### Встроенное логирование

Проект использует систему макросов для логирования из `engine.hpp`:

```sqf
#include "engine.hpp"

// Простое логирование
log("Сообщение");

// Логирование с форматированием
logformat("Модуль: Значение: %1", _value);

// Предупреждения
warning("Предупреждение");
warningformat("Модуль: Проблема: %1", _issue);

// Ошибки
error("Критическая ошибка");
errorformat("Модуль: Ошибка: %1", _errorMsg);

// Трассировка (только в DEBUG)
trace("Точка выполнения");
traceformat("Модуль: Данные: %1", _data);
```

### Breakpoints

> [!WARNING]
> **Важно:** Макрос `breakpoint()` НЕ останавливает выполнение кода! Он только логирует сообщение с информацией о номере строки и файле через `traceformat()`. Выполнение продолжается после вызова `breakpoint()`. Для отладки используйте логирование и анализируйте вывод в консоли или RPT файлах.

Используйте макрос `breakpoint()` для логирования с информацией о местоположении в коде:

```sqf
#ifdef __TRACE__ENABLED
breakpoint_setfile("MyModule.sqf");
breakpoint("Достигнута точка останова");
#endif
```

**Требования:**
- Breakpoints работают только при включенном флаге `__TRACE__ENABLED` (автоматически в DEBUG)

### Debug консоль

**Рекомендуется:** Используйте функции логирования из `engine.hpp` (`log`, `warning`, `error`, `trace`) вместо прямого вызова `debug_console`:

```sqf
#include "engine.hpp"

// Вместо прямого вызова debug_console используйте:
log("Сообщение");                    // Обычное логирование
warning("Предупреждение");           // Предупреждение
error("Ошибка");                     // Ошибка
trace("Трассировка");                // Трассировка (только в DEBUG)
```

**Преимущества использования функций логирования:**
- Автоматическое форматирование сообщений
- Отправка в RBuilder (если доступен)
- Правильные коды для разных уровней логирования (#1111 для log, #1001 для error, #1101 для warning, #1011 для trace)
- Логика для разных режимов (сервер/клиент, stdout, diag_log в продакшене)
- Единообразный стиль логирования в проекте

**Прямой вызов `debug_console`** следует использовать только в особых случаях, когда нужен низкоуровневый доступ:

```sqf
// Низкоуровневый вызов (используйте только при необходимости)
"debug_console" callExtension "message";
```

## Отладка host кода

### Логирование в RPT файлы

Серверные логи сохраняются в файлах `.rpt`:

**Расположение:**
- Windows: `%LOCALAPPDATA%\Arma 3\`
- Имя файла: `arma3server_YYYY-MM-DD_HH-MM-SS.rpt` (формат: `arma3server_x64_2025-12-21_19-05-12.rpt`)

### Отладочные макросы и флаги

Используйте флаги компиляции для отладки:

```sqf
#ifdef DEBUG
    // Код выполняется только в режиме отладки
    logformat("Debug: Значение: %1", _value);
#endif
```

### Работа с классами и объектами в отладчике

Для отладки объектов доступно несколько способов:

**1. Визуальная отладка в escape menu debug окне:**
- Нажмит Ecs, затем введите в окне отладки код для выполнения и нажмите "Локально" (Local exec) для выполнения. Для отслеживания изменения данных можете воспрользоваться 4 строками под этим окном.
- Объекты можно проверять визуально через debug окно

**2. Программная отладка в файлах:**
В файлах можно подключать макросы через `#include`, поэтому можно писать обычным кодом с использованием OOP макросов:

```sqf
#include "engine.hpp"
#include "oop.hpp"

// Получение объекта (например, через oop_getdata или другой способ)
private _obj = ["target",""] call oop_getdata select 0;

// Использование OOP макросов в файле
private _fields = getVar(_obj,__allfields);
private _value = getVar(_obj,fieldName);
setVar(_obj,fieldName,_newValue);

// Вызов методов
callFunc(_obj,someMethod);

// Вывод состояния объекта
logformat("Debug: Object state: %1", _fields);
```

**3. Отладка через debug консоль в escape меню:**
- В debug консоли escape меню переменная `this` не существует
- Для прямого доступа используйте работу с переменными Location объектов:
  ```sqf
  private _obj = ["target",""] call oop_getdata select 0;
  private _value = _obj getVariable "fieldName";
  _obj setVariable ["fieldName", _value];
  ```
- Проверяйте объекты через `valid()`, `isNullReference()`

#### Трассировка методов

В коде классов можно добавлять ручную трассировку:

```sqf
func(myMethod)
{
    objParams();
    traceformat("MyClass: myMethod called at %1 (file %2; line %3)", this arg __FILE__ arg __LINE__);
    // код метода
};
```

Или использовать макрос `setLastError()` для автоматической трассировки и вывода messagebox со стектрейсом ошибки.

```sqf
func(throwedErrorMethod)
{
    objParams();
    private _isWrongValue = true;
    if (_isWrongValue) exitWith {
        setLastError("MyClass: myMethod: Wrong value");
    };
}
```

### Профилирование производительности

Используйте макрос `tickTime` (из `engine.hpp`) для измерения времени выполнения:

```sqf
private _startTime = tickTime;
// ваш код
private _endTime = tickTime;
private _duration = _endTime - _startTime;
logformat("Performance: Execution time: %1ms", _duration * 1000);
```

**Примечание:** `tickTime` - это макрос для `diag_tickTime`, рекомендуется использовать макрос для единообразия кода.

## Отладка client кода

### Клиентские логи

Клиентские логи также сохраняются в `.rpt` файлах:

**Расположение:**
- Windows: `%LOCALAPPDATA%\Arma 3\`
- Имя файла: `arma3_x64_YYYY-MM-DD_HH-MM-SS.rpt` (формат: `arma3_x64_2025-12-21_19-05-12.rpt`)

**Важно:** На клиенте в продакшене нет стектрейсов (stack trace), потому что код собирается в один большой файл `CLIENT` через систему сборки (`bt_buildClient`). Это делает отладку на клиенте сложнее.

**Стектрейсы в RPT файлах:**
- Стектрейсы можно получить через RPT файлы клиента, но они не содержат имен функций
- Стек вызовов будет виден, но информация не очень содержательна
- Однако по месту ошибки (которое показывает кусок препроцессированного кода) и именам переменных можно понять примерно где возникла ошибка

**Как отлаживать без стектрейсов:**
- Используйте детальное логирование с указанием модуля и функции
- Анализируйте место ошибки в RPT - оно показывает кусок кода и имена переменных, что помогает локализовать проблему
- Обращайте внимание на имена переменных в стектрейсе - они могут указать на конкретный модуль или функцию
- В DEBUG режиме стектрейсы могут быть более информативными, так как код не собирается в один файл

### Отладка через ClientStatistic

Модуль `ClientStatistic` предоставляет визуальную отладку общей информации. Переключается через команду `debugvars`:

```sqf
// Включение отображения (через локальную команду в F10)
debugvars 1

// Выключение
debugvars 0
```

**Что показывает:**
- FPS (текущий, минимальный, deltaTime)
- Номер кадра
- Информация о NOEngine (количество пакетов, прогресс загрузки чанков, количество объектов)
- Информация о LightEngine
- В режиме редактора/симуляции: дополнительная информация об освещении, количестве созданных объектов и количестве активных циклов обновлений

**Примеры отображаемой информации:**
- `fps: cur:60; min:55; dt:0.016`
- `NOE packets: amount 1234; packets query 5`
- `NOE progress: {"LD","LD","NON_LD"}`
- `NOE objs: [10, 15, 8]` (количество объектов по типам чанков)

**Примечание:** `ClientStatistic` показывает только общую информацию, не детали конкретных объектов.

### Синхронизация с сервером

Отлаживайте сетевые взаимодействия:

```sqf
// На клиенте - отправка RPC на сервер
#include "clientRpc.hpp"
logformat("Client: Sending RPC: %1", _data);
rpcSendToServer("myAction", [_data]);

// На сервере - регистрация обработчика
#include "serverRpc.hpp"
private _myActionHandler = {
    params ["_data"];
    logformat("Server: Received RPC: %1", _data);
};
rpcAdd("myAction", _myActionHandler);
```

### Отладка UI (WidgetSystem)

Для отладки виджетов используйте правильный синтаксис WidgetSystem. См. раздел [Работа с WidgetSystem](../Project/03_SYNTAX_GUIDE.md#работа-с-widgetsystem) для правильных примеров создания и использования виджетов.

## Отладка editor кода

### Редакторные инструменты отладки

Редактор имеет встроенные инструменты отладки:

- **Логи редактора** - отображаются в консоли редактора
- **Инспектор объектов** - просмотр состояния игровых объектов
- **Отладчик визуального скриптинга** - для ReNode

### Логирование в редакторе

**Важно:** В редакторе не следует использовать макросы логирования из `engine.hpp` (`log`, `warning`, `error`, `trace`), потому что у редактора своя экосистема и функции, которыми обернуты эти макросы, не определены в редакторе. Для редактора предусмотрены отдельные функции логирования из модуля `Editor/Logger`:

```sqf
// Обычное логирование
["Сообщение"] call printLog;
["Модуль: Значение: %1", _value] call printLog;

// Предупреждения
["Предупреждение"] call printWarning;
["Модуль: Проблема: %1", _issue] call printWarning;

// Ошибки
["Критическая ошибка"] call printError;
["Модуль: Ошибка: %1", _errorMsg] call printError;

// Трассировка (только если включен devMode или allowTraceMessages)
["Точка выполнения"] call printTrace;
["Модуль: Данные: %1", _data] call printTrace;
```

**Особенности:**
- Функции принимают либо строку, либо массив для форматирования (как `format`)
- Логи отображаются в консоли редактора с префиксами `[REDIT::WARN]`, `[REDIT::ERROR]`, `[REDIT::TRACE]`
- `printTrace` работает только при включенном `cfg_debug_devMode` или `cfg_debug_allowTraceMessages`

### Тестирование компонентов

```sqf
function(testComponent_run)
{
    ["Testing component..."] call printLog;
    // тестовый код
}
```

### Симуляция

Используйте симуляцию в редакторе для тестирования. Для запуска симуляции в редакторе используйте стандартные функции редактора Платформы. Подробнее о работе с редактором см. в документации редактора.

**См. также:** [Глоссарий - Симуляция](GLOSSARY.md#симуляция)

## Специфичные техники

### Отладка NOEngine (репликация объектов)

NOEngine имеет специальные отладочные флаги:

```sqf
#ifdef DEBUG
    // Отображение чанков
    #define NOE_DEBUG_SHOW_CHUNKS
    
    // Отображение объектов
    #define NOE_DEBUG_SHOW_OBJECTS
#endif
```

**Что делают флаги при включении:**

- **`NOE_DEBUG_SHOW_CHUNKS`** - включает визуальное отображение чанков в 3D пространстве:
  - Рисует границы чанков (линии) вокруг позиции игрока для всех типов чанков (item, structure, decor)
  - Показывает чанки разных типов разными цветами
  - Отображает информацию о чанках: тип, состояние загрузки (NOT_LOADED/PROGR/DONE), время последнего обновления, количество объектов в чанке
  - Показывает соседние чанки вокруг текущей позиции игрока

- **`NOE_DEBUG_SHOW_OBJECTS`** - включает отображение объектов внутри чанков:
  - Показывает текстовые подсказки с именем и типом объектов в 3D пространстве (только в радиусе 60 метров от игрока)
  - Отображает информацию об объектах: ID объекта и ссылка на объект
  - Размер иконок зависит от расстояния до объекта
  - Позволяет визуально отслеживать, какие объекты находятся в каждом чанке

**Логирование репликации:**
- Логи загрузки чанков
- Логи создания объектов
- Логи синхронизации состояния

### Отладка OOP системы

#### Проверка иерархии классов

Для проверки иерархии классов используйте специальные функции OOP системы. Не логируйте все классы напрямую (их тысячи), вместо этого используйте инструменты для работы с наследованием:

**Для проверки родительских классов (вверх по иерархии):**

```sqf
// Получить имя родительского класса для объекта
private _obj = new(MyClass);
callFunc(_obj,getParentClassName);  // Возвращает имя родительского класса

// Получить цепочку всех родительских классов для объекта
callFunc(_obj,getInheritFrom);  // Возвращает массив всех родительских классов

// Получить родительский класс по имени класса (без создания объекта)
["MyClass", "__motherClass"] call oop_getTypeValue;  // Возвращает имя родительского класса
```

**Для проверки наследников класса (вниз по иерархии):**

```sqf
// Получить список прямых наследников класса
["MyClass", false] call oop_getinhlist;  // Только прямые наследники

// Получить список всех наследников класса (рекурсивно)
["MyClass", true] call oop_getinhlist;  // Все наследники, включая косвенных
```

**Для проверки переменных по индексам или диапазонам:**

```sqf
// В debug консоли можно проверить конкретные элементы
(p_table_allclassnames) select 0  // Первый класс
(p_table_allclassnames) select [0, 10]  // Первые 10 классов
```

**Важно:** Не пытайтесь логировать `p_table_allclassnames` или `p_table_inheritance` полностью - это вызовет проблемы с производительностью из-за большого объема данных.

#### Отладка создания объектов

```sqf
private _obj = new(MyClass);
traceformat("OOP: Created object: %1", _obj);

// Проверка типа объекта
private _className = callFunc(_obj,getClassName);
logformat("OOP: Object class: %1", _className);
```

### Отладка сетевого взаимодействия (RPC)

#### Включение RPC логирования

В `SETTINGS.h` можно включить логирование RPC в консоль:

```sqf
// В SETTINGS.h
#define ENABLE_RPCLOG_CONSOLE_SERVER  // Логи RPC на сервере в консоль
#define ENABLE_RPCLOG_CONSOLE_CLIENT  // Логи RPC на клиенте в консоль (отключается в релизе)
```

#### Трассировка RPC вызовов

Используйте логирование в коде для трассировки:

```sqf
// На клиенте - отправка RPC на сервер
#include "clientRpc.hpp"
traceformat("RPC: Sending myAction with %1", _data);
rpcSendToServer("myAction", [_data]);

// На сервере - в обработчике
#include "serverRpc.hpp"
private _myActionHandler = {
    params ["_data"];
    traceformat("RPC: Received myAction with %1", _data);
    // обработка
};
rpcAdd("myAction", _myActionHandler);
```

#### Эмуляция сетевой задержки

Для тестирования сетевых операций в режиме симуляции можно включить эмуляцию лага сети в `SETTINGS.h`:

```sqf
// В SETTINGS.h раскомментируйте:
#define ENABLE_LAG_NETWORK

// Настройки задержки (в миллисекундах):
#define __LAG_NETWORK_PING_MIN 1    // Минимальная задержка
#define __LAG_NETWORK_PING_MAX 10   // Максимальная задержка

// Для динамической настройки задержки включите:
#define __LAG_NETWORK_MANAGED_TICKTIME
// Тогда можно использовать функцию:
lagnet_setrange = {
    params [["_low",1,[0]],["_up",10,[0]]];
    LAG_NETWORK_TICKTIME_MIN = _low / 1000;
    LAG_NETWORK_TICKTIME_MAX = _up / 1000;
};

// Вызов: [5, 50] call lagnet_setrange;  // Задержка от 5 до 50 мс
```

**Примечание:** Эмуляция лага работает только в режиме симуляции (EDITOR или SP_MODE).

## Работа с логами

### Расположение логов

**Серверные логи:**
- Windows: `%LOCALAPPDATA%\Arma 3\`
- Имя файла: `arma3server_x64_YYYY-MM-DD_HH-MM-SS.rpt`

**Клиентские логи:**
- Windows: `%LOCALAPPDATA%\Arma 3\`
- Имя файла: `arma3_x64_YYYY-MM-DD_HH-MM-SS.rpt`

**Редакторные логи:**
- Те же пути, что и для клиента
- Ошибки редактора также попадают в логи

### Поиск в логах

Используйте поиск для нахождения ошибок:

**Ключевые слова для поиска:**
- `ERROR` - ошибки
- `WARNING` - предупреждения
- `TRACE` - трассировка
- Название модуля - логи конкретного модуля

**Формат логов:** Логи форматируются через систему логирования проекта. Формат зависит от настроек логирования в модуле `Logger`. Обычно логи содержат время, уровень важности и сообщение.

**Пример формата лога:**
```
[2025-01-15 14:30:25] [INFO] MyModule: Initializing...
[2025-01-15 14:30:26] [ERROR] MyModule: Failed to load dependency
```

**Рекомендации:**
- Используйте поиск по времени для локализации проблемы
- Ищите паттерны ошибок (повторяющиеся сообщения)
- На клиенте в продакшене нет стектрейсов (код собирается в один файл), поэтому важно использовать детальное логирование

### Работа с логами продакшн-сервера

**Особенности продакшн-логов:**
- Большой объем данных требует эффективного поиска
- Логи могут быть ротированы (старые логи удаляются)
- Важно сохранять логи для анализа критичных ошибок

**Инструменты для анализа:**
- Используйте текстовые редакторы с поддержкой больших файлов
- Применяйте grep/ripgrep для поиска по паттернам
- Фильтруйте логи по времени, модулю, уровню важности

**Типичные паттерны в продакшн-логах:**
- Ошибки загрузки модулей (проверьте порядок загрузки)
- RPC ошибки (проверьте обработчики RPC)
- OOP ошибки (проверьте объекты и методы)
- Проблемы производительности (медленные операции)

**Анализ критичных ошибок:**
1. Найдите время возникновения ошибки
2. Изучите контекст перед ошибкой (что происходило)
3. На сервере проверьте стек вызовов для понимания цепочки событий
4. Ищите связанные ошибки или предупреждения

## Профилирование производительности

### Измерение времени выполнения

Используйте макрос `tickTime` (из `engine.hpp`) для измерения времени выполнения:

```sqf
private _startTime = tickTime;
// ваш код
private _endTime = tickTime;
private _duration = _endTime - _startTime;
logformat("Performance: Execution time: %1ms", _duration * 1000);
```

**Рекомендации:**
- Измеряйте только критичные операции
- Учитывайте влияние измерения на производительность
- Используйте условную компиляцию для профилирования только в DEBUG

### Профилирование циклов

Особое внимание уделяйте циклам, так как они выполняются многократно:

```sqf
private _startTime = tickTime;
{
    // операции в цикле
} forEach _largeArray;
private _duration = tickTime - _startTime;
logformat("Performance: Loop execution time: %1ms for %2 items", _duration * 1000 arg count _largeArray);
```

**Оптимизация циклов:**
- Избегайте создания объектов внутри циклов (по возможности)
- Кэшируйте результаты вычислений
- Используйте эффективные алгоритмы

### Профилирование сетевых операций

Для профилирования сетевых операций можно использовать эмуляцию лага (см. раздел [Эмуляция сетевой задержки](#эмуляция-сетевой-задержки)).

**Примечание:** Для асинхронных RPC вызовов измерение времени требует специальной логики с callback'ами.

### Выявление узких мест

**Типичные узкие места:**
- Создание объектов в циклах
- Неоптимальные алгоритмы поиска
- Частые сетевые запросы
- Большие операции с массивами

**Методы выявления:**
- Профилируйте код по частям
- Используйте логирование времени выполнения
- Анализируйте логи на медленные операции

**Пример измерения:**
```sqf
private _start = tickTime;
// код
private _duration = tickTime - _start;
logformat("Performance: Execution time: %1ms", _duration * 1000);
```

### Инструменты профилирования

**Встроенные инструменты:**
- `tickTime` - измерение времени (макрос для `diag_tickTime`)
- `ClientStatistic` - визуальная статистика (FPS, память, NOEngine)
- Логирование производительности

**Рекомендации:**
- Профилируйте код в условиях, близких к продакшн
- Учитывайте нагрузку при профилировании
- Сравнивайте производительность до и после оптимизаций

## Типичные проблемы

Этот раздел содержит краткий обзор типичных проблем. Подробные описания и решения см. в [Типичные проблемы и их решения](10_TROUBLESHOOTING.md).

### Runtime ошибки

В Платформе ошибки времени выполнения имеют специфический формат. Типичные форматы ошибок:

**Формат ошибок:**
- `Error in expression: <выражение>`
- `Error position: <позиция>`
- `File: <путь к файлу>, line: <номер строки>`
- `Error: <тип ошибки>`

**Основные типы ошибок:**

1. **Generic Error in Expression** (Type: Normal):
   - Тип аргумента команды неверен
     - **Пример:** `systemChat 10`
   - Команда, которая может выполняться только в scheduled окружении, была вызвана в unscheduled окружении
     - **Пример:** `sleep 10`

2. **Zero Divisor** (Type: Normal):
   - Число было разделено на 0
     - **Пример:** `10 / 0`
   - Был получен доступ к несуществующему индексу массива
     - **Пример:** `[1,2,3] select 20`

3. **Attempt to override final function** (Type: Normal):
   - Попытка переопределить функцию, помеченную как `compileFinal`
   - **Пример:** `BIS_fnc_endMission = {systemChat "Trying to do bad things"}`

4. **getVariable called on null object** (Type: DebugOnly):
   - `getVariable` был вызван на null объекте
   - **Пример:** `objNull getVariable "varname"`

5. **getVariable called on null group** (Type: DebugOnly):
   - `getVariable` был вызван на null группе
   - **Пример:** `grpNull getVariable "varname"`

6. **Serialization of Control variables is not implemented** (Type: Normal):
   - Переменные Control не могут быть сохранены игрой при сохранении миссии, так как они специфичны для времени загрузки. Ошибка возникает, если такой элемент сохранен в `missionNamespace` или скрипт, использующий переменные Control, не выполнил `disableSerialization` перед использованием
   - **Решение:** Храните значения Control в `uiNamespace` вместо `missionNamespace` и убедитесь, что скрипты, работающие с этими переменными, используют `disableSerialization`
   - **Пример:** `cant_put_that_here = allControls (allDisplays # 0)`

**Обработка ошибок через ScriptErrorHandler:**

Проект использует модуль `ScriptErrorHandler` для перехвата и обработки ошибок времени выполнения. При возникновении ошибки:

- Ошибка автоматически перехватывается через `addMissionEventHandler ["ScriptError", ...]`
- Выводится в консоль через `cprintErr`
- Логируется в файлы через `logError` (если модуль Logger загружен)
- Отображается message box с подробной информацией об ошибке, включая:
  - Текст ошибки
  - Файл и номер строки
  - Полный стектрейс с информацией о вызовах функций и локальных переменных

Также можно программно установить ошибку с помощью макроса `setLastError()`, который автоматически вызовет обработчик ошибок и покажет message box:

```sqf
if (_invalidCondition) exitWith {
    setLastError("MyClass: myMethod: Invalid value provided");
};
```

**Примечание:** Полный список форматов ошибок и их описаний см. в [официальной документации Платформы](https://community.bistudio.com/wiki/Arma_3:_Error_Messages).

**См. также:** [Типичные проблемы - Runtime ошибки](10_TROUBLESHOOTING.md#runtime-ошибки)

### Проблемы загрузки модулей

- **Модуль не загружается** - не зарегистрирован в загрузчике или ошибки компиляции
- **Неправильный порядок загрузки** - модуль загружается раньше зависимостей
- **Циклические зависимости** - модули зависят друг от друга циклически

**См. также:** [Типичные проблемы - Проблемы загрузки модулей](10_TROUBLESHOOTING.md#проблемы-загрузки-модулей)

### Проблемы производительности

- **Медленные операции в циклах** - дорогие операции выполняются многократно
- **Утечки памяти** - объекты не удаляются после использования
- **Слишком частые сетевые запросы** - высокая сетевая нагрузка

**См. также:** [Типичные проблемы - Проблемы производительности](10_TROUBLESHOOTING.md#проблемы-производительности)

### Отладка OOP системы

- **Объект не создается** - класс не был загружен или ошибка в конструкторе
- **Метод не вызывается** - метод не определен или неправильное использование макросов
- **Проблемы с наследованием** - неправильное использование наследования
- **Проблемы с полями объекта** - поле не было инициализировано

**См. также:** [Типичные проблемы - Отладка OOP системы](10_TROUBLESHOOTING.md#отладка-oop-системы)

### Проблемы редактора

- **Редактор не загружается** - мод @EditorContent не установлен или BattlEye включен
- **Ошибки компиляции** - синтаксические ошибки в коде редактора
- **Проблемы с визуальным отображением в редакторе** - проблемы с кодом (ошибки в коде редактора) или проблема с @EditorContent

**См. также:** [Типичные проблемы - Проблемы редактора](10_TROUBLESHOOTING.md#проблемы-редактора)

## Лучшие практики

### Структурированное логирование

```sqf
// Используйте префиксы для группировки (в строке)
#define LOG_PREFIX "MyModule"

log(LOG_PREFIX + ": Initializing...");  // Простое сообщение - используйте log()
logformat(LOG_PREFIX + ": Value: %1", _value);  // С форматированием - используйте logformat()
```

### Условное логирование

```sqf
#ifdef DEBUG
    #define DEBUG_LOG(msg) log("Debug: " + msg)  // Простое сообщение - используйте log()
    #define DEBUG_LOG_FORMAT(fmt,args) logformat("Debug: " + fmt, args)  // С форматированием - используйте logformat()
#else
    #define DEBUG_LOG(msg)
    #define DEBUG_LOG_FORMAT(fmt,args)
#endif

DEBUG_LOG("This only logs in DEBUG mode");
DEBUG_LOG_FORMAT("Value: %1", _value);
```

### Проверка состояний

```sqf
// Проверка валидности перед использованием
if (!valid(_obj)) exitWith {
    error("MyModule: Object is invalid");
};
```

## Что дальше?

- ➡️ [Типичные проблемы и их решения](10_TROUBLESHOOTING.md) - подробные описания проблем и решений
- ➡️ [Модульная система](04_MODULE_SYSTEM.md) - отладка модулей
- ➡️ [Быстрый справочник](QUICK_REFERENCE.md) - макросы для отладки
