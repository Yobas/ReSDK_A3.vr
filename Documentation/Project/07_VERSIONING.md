# Версионирование и релизы

Проект использует семантическое версионирование для управления версиями.

## Система версионирования

### Файл VERSION

Основная версия проекта хранится в файле `Src/VERSION`:

```
1.9.1
```

**Формат:** `MAJOR.MINOR.PATCH`

- **MAJOR** - крупные изменения, нарушающие совместимость
- **MINOR** - новые функции, обратно совместимые
- **PATCH** - исправления багов, обратно совместимые

### Обновление версии

Файл `VERSION` обновляется **непосредственно перед выпуском новой версии**.

**Важно:** Не обновляйте версию в процессе разработки, только перед релизом.

### Файл REVISION

**Используется сервисом обновления для сборки.** Файл `Src/REVISION` содержит Git SHA коммита и обновляется автоматически сервисом обновления при сборке dev-версий. В процессе разработки этот файл обычно содержит `Unrevisioned`.

**Важно для разработчиков:** Не нужно обновлять REVISION вручную - это делает сервис обновления при сборке.

## Автоматическая сборка сервисом обновления

Проект собирается **сервисом обновления** - внешним Python-скриптом, работающим на сервере. Сервис автоматически отслеживает коммиты и релизы в репозитории GitHub через GitHub API и выполняет сборку и деплой без участия разработчиков.

**Процесс работы сервиса:**

1. **Отслеживание:** Периодически проверяет репозиторий через GitHub API на наличие новых коммитов в `main` (включая мержи) и новых релизов
2. **Скачивание:** При обнаружении изменений скачивает архив репозитория
3. **Подготовка:** Обновляет `VERSION`, `REVISION`, копирует `private.h`, обновляет `CHANGELOGS.txt` (для релизов)
4. **Сборка:** Запускает ReNode для подготовки графов, затем RBuilder для сборки проекта
5. **Деплой:** Развертывает собранную версию на серверах
6. **Уведомления:** Отправляет уведомления в Discord о процессе сборки

**Важно:** Сервис работает полностью автоматически и не требует действий от разработчиков. Автоматическая сборка происходит при мерже в ветку `main` и при выпуске нового релиза.

### Dev-версии (локальная разработка)

**Dev-версии используются для локальных экспериментов** и разработки новых функций, которые позже попадут в `main`. Они **не собираются на сервере** сервисом обновления.

**Особенности dev-версий:**
- Используются разработчиками для экспериментов и тестирования новых функций
- Например, экспериментальные функции редактора, которые позже будут интегрированы в main
- Собираются локально разработчиками по необходимости
- Не требуют `private.h` (если не используется шифрование)
- `REVISION` обычно содержит `Unrevisioned` в процессе разработки

**Важно:** Сервис обновления отслеживает и собирает только релизные версии из ветки `main`.

### Файл private.h

**Приватный файл конфигурации.** Файл `Src/private.h` содержит секретные настройки сервера и **не хранится в публичном репозитории**.

**Содержимое:**
- `REMAKER_PRIVATE_COMPILE_CRYPT` - секретное значение для валидации возможности компиляции с криптографией
- `server_password` - пароль для управления сервером Arma 3 (используется для команд `#lock`, `#unlock`, `#kick`)
- `CRYPT_KEY` - ключ шифрования для клиентской части (строка чисел)
- `CRYPT_SAVE_AS_BINARY` - флаг сохранения клиентской части в бинарном формате (для обфускации)
- `CRYPT_ENABLED` - флаг включения шифрования (на продакшн-сервере выключен)
- `RC_CLIENT_KEY` - ключ клиента (генерируется автоматически из `CRYPT_KEY` как инвертированная версия)
- Функции шифрования/дешифрования (`rc_flow`, `rc_deflow`, `rc_generateKey` и другие)
- Настройки голосового канала (`tf_radio_channel_name`, `tf_radio_channel_password`)
- Настройки сервера голоса (`vs_serverAddrPortPass`)
- Функции авторизации через Discord (`srv_auth_*`)

**Примечание о криптовании:**
До выхода проекта в open-source клиентские исходники шифровались ключом (`CRYPT_KEY`) и расшифровывались при подключении клиента к серверу. Это обеспечивало защиту исходного кода от просмотра. После перехода проекта на open-source необходимость в такой защите отпала, так как исходный код стал публично доступным. Поэтому на продакшн-сервере `CRYPT_ENABLED` выключен, хотя инфраструктура шифрования сохранена в коде для обратной совместимости.

**Важно для разработчиков:**
- Файл находится на сервере сервиса обновления в защищенном хранилище
- Файл автоматически копируется сервисом обновления в репозиторий при сборке релизов
- Файл попадает в билд, когда сервис обновления собирает проект через RBuilder
- **При локальной разработке файл не требуется** (если не используется шифрование и авторизация)
- Если файл отсутствует, используется значение по умолчанию `CRYPT_KEY = "public_build"`
- В режиме `EDITOR` все криптографические переменные устанавливаются в `null`
- Файл компилируется через препроцессор при сборке проекта в `fn_init.sqf`

**Использование в коде:**
```sqf
// В fn_init.sqf - проверка и компиляция
if (fileExists("src\private.h")) then {
    private _CRYPT_COMPILE_SERVER_ = true;
    call compile __pragma_preprocess ("src\private.h");
};

// SERVER_PASSWORD используется для управления сервером
SERVER_PASSWORD serverCommand "#lock";
SERVER_PASSWORD serverCommand "#unlock";
```

**Безопасность:**
- Никогда не коммитьте `private.h` в репозиторий
- Файл должен храниться только в защищенном внешнем хранилище
- Содержит реальные пароли и ключи шифрования для продакшн-серверов

### Релизные версии (автоматическая сборка на сервере)

При публикации релиза на GitHub сервис обновления автоматически:
1. Обнаруживает новый релиз по тегу
2. Скачивает релизный архив
3. Обновляет `VERSION` с версией из тега релиза
4. Обновляет `REVISION` с SHA коммита тега
5. Обновляет `CHANGELOGS.txt` с описанием релиза
6. Копирует `private.h` из внешнего источника конфигурации
7. Запускает ReNode для подготовки графов
8. Запускает RBuilder для сборки релизной версии
9. Деплоит релизную сборку

### Автоматическое формирование версий при сборке

При сборке проекта версия из `VERSION` автоматически:
- Встраивается в клиентский код
- Добавляется в серверный код
- Отображается в логах и интерфейсе

### Использование версии в коде

```sqf
// Версия доступна через переменную
client_version  // версия клиента (из VERSION)
relicta_version // версия сервера (из VERSION)
// REVISION используется сервисом обновления для отслеживания коммита
```

## Синхронизация версий

### Проверка версий при подключении

При подключении клиента к серверу происходит проверка совместимости версий:

```sqf
// Автоматическая проверка
if (client_version != relicta_version) then {
    // Предупреждение или отключение
};
```

### Совместимость версий

- **MAJOR версии** - не совместимы между собой
- **MINOR версии** - могут быть совместимы (зависит от изменений)
- **PATCH версии** - должны быть совместимы

## Процесс создания релизов

Процесс создания релизов автоматизирован через GitHub Actions и Release Drafter.

### Шаг 1: Подготовка к релизу

1. Убедитесь, что все изменения закоммичены в `main`
2. Проверьте, что все тесты пройдены
3. Обновите документацию, если необходимо
4. Убедитесь, что все PR помечены соответствующими лейблами (см. Шаг 2)

### Шаг 2: Обновление версии (bump version)

**Важно:** Версия обновляется **вручную** перед выпуском релиза. Версия должна соответствовать тому, что будет в draft релиза.

1. Проверьте draft релиза на странице Releases в GitHub, чтобы узнать, какая версия будет автоматически определена Release Drafter
2. Откройте файл `Src/VERSION`
3. Обновите версию согласно семантическому версионированию:

   **Важно:** Файл `VERSION` должен содержать только одну строку с версией (например, `1.9.2`). Не добавляйте вторую строку или дополнительные символы. Хотя remaker имеет защиту от этой проблемы, такую ошибку лучше не допускать.
   - **PATCH** (1.9.1 → 1.9.2) - для исправлений багов
   - **MINOR** (1.9.1 → 1.10.0) - для новых функций
   - **MAJOR** (1.9.1 → 2.0.0) - для крупных изменений

**Пример:**
```
1.9.1  → 1.9.2  # Исправление бага
1.9.1  → 1.10.0 # Новая функция
1.9.1  → 2.0.0  # Крупное изменение
```

4. Закоммитьте изменение версии:
```bash
git add Src/VERSION
git commit -m "Prep 1.9.2"
git push origin main
```

**Важно:** Версия в `Src/VERSION` должна соответствовать версии, которая будет в draft релиза после этого коммита.

### Шаг 3: Release Drafter

**Release Drafter** - это GitHub Actions workflow, который автоматически создает и обновляет draft релизов. Конфигурация workflow находится в `.github/release-drafter.yml`.

**Как работает Release Drafter:**

- **Автоматическое создание:** При каждом push в `main` создается или обновляется draft релиза
- **Определение типа версии:** На основе лейблов PR:
  - `Major update` → увеличивает MAJOR версию
  - `Minor update` → увеличивает MINOR версию  
  - `Patch update` → увеличивает PATCH версию (по умолчанию)
- **Автоматический changelog:** Генерируется из объединенных PR с соответствующими лейблами:
  - `Feature`, `Enhancement` → раздел "Добавлено"
  - `Bug fix`, `Bug` → раздел "Исправлено"
  - `Server` → раздел "Сервер"
  - `Client` → раздел "Клиент"
  - `Editor` → раздел "Редактор"

**Связь с GitHub Actions:** Release Drafter является частью GitHub Actions workflows проекта. При публикации релиза автоматически запускается сервис обновления для сборки и деплоя.

### Шаг 4: Публикация релиза через веб-интерфейс GitHub

1. Перейдите на страницу Releases в GitHub
2. Откройте draft релиза
3. Проверьте, что версия в draft соответствует версии в `Src/VERSION`
4. Проверьте автоматически сгенерированный changelog
5. При необходимости отредактируйте описание и changelog
6. Нажмите "Publish release"

**Важно:** 
- При публикации релиза автоматически создается Git тег в формате `vMAJOR.MINOR.PATCH`
- После публикации сервис обновления автоматически обнаружит релиз и выполнит сборку и деплой

### Шаг 5: Автоматическое обновление changelog и документации

После публикации релиза:

- **Changelog обновляется автоматически**: Сервис обновления автоматически синхронизирует changelog из релиза в `Src/CHANGELOGS.txt` после деплоя релиза через workflow "Sync changelogs on deploy release"

- **Документация генерируется автоматически**: При каждом push в `main` GitHub Actions автоматически генерирует API документацию через `Third-party/Docgen` и коммитит изменения в `Documentation/API/**`

**Важно:** Разработчикам не нужно вручную обновлять changelog или документацию - это происходит автоматически.

### Шаг 6: Автоматическое развертывание

После публикации релиза:

1. **Сервис обновления автоматически:**
   - Обнаружит новый релиз
   - Обновит `VERSION` и `REVISION` файлы
   - Соберет релизную версию через RBuilder
   - Развернет на серверах

2. **Мониторинг:**
   - Сервис обновления отправляет уведомления в Discord о процессе сборки
   - Проверьте логи сервиса на ошибки сборки
   - Проверьте логи сервера после развертывания

**Важно:** Разработчикам не нужно вручную собирать и деплоить релизы - это делает сервис обновления автоматически.

## Версионирование компонентов

### Основной проект

Версия основного проекта управляется через `Src/VERSION`.

### Внешние компоненты

Внешние компоненты (RVEngine, ReBridge) могут иметь собственное версионирование:
- RVEngine имеет отдельную систему версионирования (см. документацию RVEngine)
- Эти версии независимы от версии основного проекта

## Рекомендации по версионированию

### Лейблы для PR

При создании Pull Request используйте соответствующие лейблы для автоматического определения типа версии:

- **`Major update`** - для изменений, требующих увеличения MAJOR версии
- **`Minor update`** - для изменений, требующих увеличения MINOR версии
- **`Patch update`** - для изменений, требующих увеличения PATCH версии (по умолчанию)

### Когда увеличивать PATCH

- Исправления багов (лейбл: `Bug fix` или `Bug`)
- Мелкие улучшения
- Обновления документации (только если критично)

**Лейбл:** `Patch update` (или без лейбла, так как это значение по умолчанию)

### Когда увеличивать MINOR

- Добавление новых функций (лейбл: `Feature` или `Enhancement`)
- Добавление новых модулей
- Расширение API (обратно совместимое)

**Лейбл:** `Minor update`

### Когда увеличивать MAJOR

- Изменения, нарушающие обратную совместимость
- Крупные рефакторинги архитектуры
- Удаление устаревших функций

**Лейбл:** `Major update`

### Дополнительные лейблы

Для категоризации в changelog используйте:
- `Server` - изменения на сервере
- `Client` - изменения на клиенте
- `Editor` - изменения в редакторе
- `Documentation` - изменения в документации
- `Common` - общие изменения

## CI/CD и автоматизация

### GitHub Actions Workflows

Проект использует следующие workflows для автоматизации:

#### Release Drafter (`drafts.yml`)

Автоматически создает и обновляет draft релизов:
- Запускается при каждом push в `main`
- Определяет тип версии на основе лейблов PR
- Генерирует changelog из объединенных PR
- Использует конфигурацию из `.github/release-drafter.yml`

#### Build Workflow (`all_build.yml`)

Выполняет сборку и валидацию:
- Валидация карт и графов
- Сборка RVEngine
- Автоматическая генерация API документации (при push в `main`)
- Запускается при push в `main` или создании PR

**Генерация документации:**
- Запускается автоматически при каждом push в `main` (job `generatedocs`)
- Использует `Third-party/Docgen/main.py` для генерации API документации
- Автоматически коммитит изменения в `Documentation/API/**`

#### Sync Changelogs (`sync_changelogs.yml`)

Синхронизирует changelog из релиза в репозиторий:
- Запускается автоматически сервисом обновления после деплоя релиза
- Сохраняет changelog в `Src/CHANGELOGS.txt`
- Также может быть запущен вручную через `workflow_dispatch` при необходимости
- Также может быть запущен вручную через `workflow_dispatch` при необходимости

### Автоматическое определение версии

Release Drafter автоматически определяет тип версии на основе лейблов последнего мержа в `main`:

1. Проверяет лейблы объединенных PR
2. Использует лейбл с наивысшим приоритетом (Major > Minor > Patch)
3. Увеличивает соответствующую часть версии
4. Если лейбл не указан, используется `patch` (по умолчанию)

**Важно:** Версия в файле `Src/VERSION` должна быть обновлена вручную перед созданием релиза, чтобы соответствовать автоматически определенной версии Release Drafter.

## Что дальше?

- ➡️ [Сборка и деплой](06_BUILD_DEPLOY.md) - процесс сборки релизной версии
- ➡️ [Процессы разработки](08_DEVELOPMENT_WORKFLOW.md) - workflow для релизов

