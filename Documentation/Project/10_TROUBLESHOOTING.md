# Типичные проблемы и их решения

Этот документ содержит описание типичных проблем, возникающих при разработке и поддержке проекта, а также способы их решения.

## Runtime ошибки

### Ошибка "undefined variable" или "nil value"

**Симптомы:**
- Ошибка выполнения с сообщением об undefined variable
- Неожиданное поведение из-за nil значений

**Причины:**
- Переменная не была инициализирована
- Переменная объявлена с неправильным scope
- Ошибка в именовании переменной

**Решение:**
```sqf
// Всегда проверяйте переменные перед использованием
if (isNullVar(_myVar)) then {
    _myVar = defaultValue;
};

// Используйте valid() для проверки объектов
if (!valid(_obj)) exitWith {
    error("MyModule: Object is invalid");
};
```

**Профилактика:**
- Всегда объявляйте локальные переменные с `private`
- Используйте проверки на null перед использованием объектов
- Используйте `defIsNull()` для значений по умолчанию

**Особенности работы с null значениями:**
- `if (null) then {} else {}` - обе ветки никогда не выполнятся (см. [Работа с null значениями](../Project/03_SYNTAX_GUIDE.md#работа-с-null-nil-значениями))
- `_array pushBack null` - null значение не будет добавлено, используйте `_array append [null]`
- Всегда проверяйте значения на null перед использованием в операциях

### Ошибка "Error: Cannot call (nil value)"

**Симптомы:**
- Ошибка при попытке вызвать функцию
- Функция не была определена или загружена

**Причины:**
- Модуль не был загружен до использования
- Ошибка в имени функции
- Функция была удалена или переименована

**Решение:**
- Проверьте, что модуль загружен перед использованием
- Убедитесь, что функция существует и правильно названа
- Проверьте порядок загрузки модулей в `host/init.sqf` или `client/loader.hpp`

**Профилактика:**
- Документируйте зависимости модулей
- Используйте проверки существования функции перед вызовом (если возможно)

### Ошибка "Array index out of range"

**Симптомы:**
- Ошибка при обращении к элементу массива по индексу
- Неожиданное поведение при работе с массивами

**Причины:**
- Попытка доступа к несуществующему индексу
- Массив пустой или имеет меньше элементов, чем ожидается

**Решение:**
```sqf
// Всегда проверяйте размер массива перед доступом
if (count _array > _index) then {
    private _value = _array select _index;
} else {
    errorformat("MyModule: Array index %1 out of range", _index);
};

// Используйте array_exists() для проверки существования элемента
if (array_exists(_array, _item)) then {
    // элемент существует
};
```

**Профилактика:**
- Используйте проверки размера массива перед доступом
- Используйте безопасные функции работы с массивами

### Ошибка типов (type mismatch)

**Симптомы:**
- Ошибка при выполнении операции с неверным типом данных
- Неожиданное поведение при работе с данными

**Причины:**
- Переменная имеет другой тип, чем ожидается
- Ошибка в передаче параметров

**Решение:**
```sqf
// Проверяйте тип перед использованием
if (not_equalTypes(_value, "")) exitWith {
    errorformat("MyModule: Expected string, got %1", typeName _value);
};

// Используйте equalTypes() для сравнения типов
if (equalTypes(_obj1, _obj2)) then {
    // объекты одного типа
};
```

**Профилактика:**
- Всегда проверяйте типы данных перед использованием
- Используйте типизированные макросы (`var_num`, `var_str`, и т.д.)

## Проблемы загрузки модулей

### Модуль не загружается

**Симптомы:**
- Модуль не инициализируется
- Функции модуля недоступны
- Ошибки компиляции при загрузке модуля

**Причины:**
- Модуль не зарегистрирован в загрузчике
- Синтаксические ошибки в модуле
- Зависимости модуля не загружены

**Решение:**
1. Проверьте регистрацию модуля:
   - Для host: добавьте в `host/init.sqf` через `loadFile()`
   - Для client: добавьте в `client/loader.hpp` через `importClient()`
   - Для editor: добавьте в `Editor/Editor_init.sqf` через `componentInit()`

2. Проверьте синтаксис модуля:
   - Убедитесь, что файл `*_init.sqf` существует
   - Проверьте наличие синтаксических ошибок

3. Проверьте зависимости:
   - Убедитесь, что все зависимости загружены до модуля
   - Проверьте порядок загрузки модулей

**Профилактика:**
- Документируйте зависимости модуля
- Следуйте порядку загрузки, указанному в документации
- Проверяйте логи при загрузке модулей

### Неправильный порядок загрузки модулей

**Симптомы:**
- Ошибки "undefined variable" или "Cannot call (nil value)"
- Модуль пытается использовать функции другого модуля, который еще не загружен

**Причины:**
- Модуль загружается раньше своих зависимостей
- Нарушен порядок загрузки, указанный в документации

**Решение:**
1. Проверьте зависимости модуля
2. Переместите модуль в правильное место в загрузчике:
   - В `host/init.sqf` модули загружаются последовательно
   - В `client/loader.hpp` порядок определяется порядком `importClient()`

3. Убедитесь, что базовые системы загружены первыми:
   - `engine.hpp` должен быть включен до использования макросов
   - OOP engine должен быть загружен до использования классов
   - `Networking` должен быть загружен до использования RPC

**Профилактика:**
- Всегда документируйте зависимости модуля
- Следуйте порядку загрузки из документации
- Комментируйте причины порядка загрузки в коде

### Циклические зависимости

**Симптомы:**
- Модули зависят друг от друга циклически
- Невозможно определить правильный порядок загрузки

**Причины:**
- Плохое разделение ответственности модулей
- Нарушение принципа модульности

**Решение:**
1. Выявите циклическую зависимость
2. Вынесите общий функционал в отдельный модуль или `CommonComponents/`
3. Пересмотрите архитектуру модулей

**Профилактика:**
- Избегайте циклических зависимостей на этапе проектирования
- Используйте `CommonComponents/` для общего функционала
- Разделяйте ответственность модулей четко

## Проблемы производительности

### Медленные операции в циклах

**Симптомы:**
- Задержки при выполнении кода
- Низкий FPS во время выполнения определенных операций

**Причины:**
- Дорогие операции выполняются в цикле
- Неоптимальные алгоритмы

**Решение:**
```sqf
// Избегайте создания объектов в цикле
private _processor = new(MyClass);
{
    callFunc(_processor,process, [_x]);
} forEach _largeArray;
delete(_processor);

// Кэшируйте результаты вычислений
private _cachedValue = call expensiveCalculation;
{
    [_cachedValue] call useValue;
} forEach _array;
```

**Профилактика:**
- Профилируйте код для выявления узких мест
- Избегайте создания объектов в циклах
- Кэшируйте результаты дорогих вычислений

### Утечки памяти

**Симптомы:**
- Постепенное увеличение использования памяти
- Производительность снижается со временем

**Причины:**
- Объекты не удаляются после использования
- Обновления (updates) не останавливаются

**Решение:**
```sqf
// Всегда удаляйте объекты после использования
{
    private _obj = new(MyClass);
    // использование объекта
    delete(_obj);
} forEach _array;

// Останавливайте updates при удалении объекта
func(destructor)
{
    objParams();
    if (!isNullVar(_updateHandle)) then {
        stopUpdate(_updateHandle);
    };
};
```

**Профилактика:**
- Всегда удаляйте объекты после использования
- Используйте `autoref` для автоматической очистки ссылок
- Останавливайте updates и event handlers при удалении объектов

### Слишком частые сетевые запросы

**Симптомы:**
- Высокая сетевая нагрузка
- Задержки при сетевых операциях

**Причины:**
- RPC вызовы выполняются слишком часто
- Отсутствие кэширования сетевых данных

**Решение:**
- Кэшируйте результаты сетевых запросов
- Используйте батчинг для множественных запросов
- Оптимизируйте частоту обновлений сетевых систем (NOEngine, синхронизация данных, RPC)

**Профилактика:**
- Минимизируйте количество RPC вызовов
- Используйте эффективные протоколы синхронизации
- Кэшируйте сетевые данные на клиенте

## Отладка OOP системы

### Объект не создается

**Симптомы:**
- `new(MyClass)` возвращает null или invalid объект
- Ошибки при попытке использовать объект

**Причины:**
- Класс не был загружен или не существует
- Ошибка в конструкторе класса
- Проблемы с OOP engine

**Решение:**
```sqf
// Проверяйте результат создания объекта
private _obj = new(MyClass);
if (!valid(_obj)) exitWith {
    error("MyModule: Failed to create MyClass object");
};

// Проверяйте, что класс существует
if (!isImplementClass("MyClass")) exitWith {
    error("MyModule: Class MyClass is not loaded");
};
```

**Профилактика:**
- Убедитесь, что класс объявлен и загружен
- Проверяйте валидность объектов после создания
- Используйте `valid()` для проверки объектов

### Метод не вызывается или вызывается неправильно

**Симптомы:**
- Метод не выполняется
- Ошибки при вызове метода
- Неправильные параметры метода

**Причины:**
- Метод не определен в классе
- Неправильное использование макросов вызова
- Проблемы с параметрами метода

**Решение:**
```sqf
// Проверяйте существование метода перед вызовом
if (!isImplementFunc(_obj,myMethod)) exitWith {
    error("MyModule: Method myMethod not found");
};
callFunc(_obj,myMethod);

// Убедитесь, что используете правильный макрос
callSelf(myMethod);                    // Без параметров
callSelfParams(myMethod, [param1 arg param2]); // С параметрами

// Проверяйте параметры метода
func(myMethod)
{
    objParams_2(_param1, _param2);
    if (isNullVar(_param1)) exitWith {
        error("MyClass: myMethod: param1 is required");
    };
    // остальной код метода
};
```

**Профилактика:**
- Используйте правильные макросы для вызова методов
- Всегда используйте `objParams()` в методах
- Проверяйте параметры методов перед использованием

### Проблемы с наследованием

**Симптомы:**
- Метод родительского класса не вызывается
- Поля родительского класса недоступны
- Ошибки при вызове `super()`

**Причины:**
- Неправильное использование наследования
- Ошибки в вызове базового метода

**Решение:**
```sqf
// Используйте super() для вызова базового метода
class(ChildClass) extends(ParentClass)
    func(overrideMethod)
    {
        objParams();
        // Вызов базового метода
        private _result = super();
        // Дополнительная логика
        _result
    };
endclass

// Проверяйте наследование
if (isTypeOf(_obj,ParentClass)) then {
    // объект является экземпляром ParentClass или его наследника
};
```

**Профилактика:**
- Используйте `super()` для вызова базовых методов
- Проверяйте типы объектов при работе с наследованием
- Документируйте иерархию классов

### Проблемы с полями объекта

**Симптомы:**
- Поле недоступно или имеет неправильное значение
- Ошибки при доступе к полю

**Причины:**
- Поле не было инициализировано
- Неправильное имя поля
- Проблемы с областью видимости

**Решение:**
```sqf
class(MyClass) extends(BaseClass)
    // Объявление полей должно быть в теле класса, не внутри методов
    var(myField, defaultValue);  // Правильно: объявление в теле класса
    
    func(constructor)
    {
        objParams();
        // В конструкторе можно установить значение для уже объявленного поля
        setSelf(myField, defaultValue);  // Правильно: установка значения уже объявленного поля
    };
endclass

// Проверяйте существование поля
if (isImplementVar(_obj,myField)) then {
    private _value = getVar(_obj,myField);
};

// Используйте правильные макросы для работы с полями
getSelf(myField);              // Внутри метода класса
getVar(_obj,myField);         // Извне класса
```

**Важно:** Все поля класса должны быть объявлены через `var()` в теле класса. `var()` и `func()` могут использоваться **только в теле класса** (между `class()` и `endclass`), но **не внутри методов**. Подробнее см. [Стандарты кодирования - Динамическое создание полей в конструкторе](09_CODING_STANDARDS.md#динамическое-создание-полей-в-конструкторе).

**Профилактика:**
- Всегда инициализируйте поля в конструкторе
- Используйте правильные макросы для доступа к полям
- Проверяйте существование полей перед использованием

## Проблемы редактора

### Редактор не загружается

**Симптомы:**
- Редактор не запускается
- Ошибки при загрузке редактора
- Модули редактора не загружаются

**Причины:**
- Мод @EditorContent не установлен
- BattlEye включен (должен быть отключен)
- Ошибки в коде редактора

**Решение:**
1. Убедитесь, что мод @EditorContent установлен:
   - Запустите `RBuilder/DEPLOY.bat` или `rb deploy -editor`
   - Проверьте наличие папки `@EditorContent` в директории Arma 3

2. Отключите BattlEye в настройках лаунчера

3. Проверьте логи на ошибки загрузки

**Профилактика:**
- Всегда проверяйте установку @EditorContent после обновления
- Документируйте требования для работы редактора

### Ошибки компиляции в редакторе

**Симптомы:**
- Ошибки компиляции при загрузке редактора
- Модули редактора не компилируются

**Причины:**
- Синтаксические ошибки в коде редактора
- Проблемы с зависимостями
- Ошибки в компонентах редактора

**Решение:**
1. Проверьте синтаксис кода редактора
2. Убедитесь, что все зависимости загружены
3. Проверьте логи редактора на детали ошибок

**Профилактика:**
- Проверяйте синтаксис перед коммитом
- Тестируйте редактор после изменений
- Используйте линтеры и валидаторы кода

### Проблемы с визуальными компонентами

**Симптомы:**
- Визуальные компоненты не отображаются
- Ошибки при работе с 3D объектами в редакторе

**Причины:**
- Проблемы с загрузкой моделей
- Ошибки в коде визуальных компонентов
- Проблемы с синхронизацией состояния

**Решение:**
- Проверьте наличие моделей и их пути
- Проверьте логи на ошибки загрузки моделей
- Убедитесь, что визуальные компоненты правильно инициализированы

**Профилактика:**
- Тестируйте визуальные компоненты после изменений
- Документируйте требования к моделям и ресурсам

## Общие рекомендации по отладке

### Использование логирования

```sqf
// Используйте разные уровни логирования
log("Информационное сообщение");
warning("Предупреждение");
error("Ошибка");

// Используйте трассировку для отладки (только в DEBUG)
trace("Точка выполнения");
traceformat("Debug: Значение: %1", _value);
```

### Использование breakpoints

```sqf
#ifdef __TRACE__ENABLED
breakpoint_setfile("MyModule.sqf");
breakpoint("Достигнута точка останова");
#endif
```

### Проверка состояния объектов

```sqf
// Проверка валидности объекта
if (!valid(_obj)) exitWith {
    error("MyModule: Object is invalid");
};

// Получение всех полей объекта (для отладки)
private _fields = (this getVariable PROTOTYPE_VAR_NAME) getVariable "__allfields";
logformat("Debug: Object fields: %1", _fields);
```

### Работа с логами

- Логи сервера: `%LOCALAPPDATA%\Arma 3\arma3server_YYYYMMDD_HHMMSS.rpt`
- Логи клиента: `%LOCALAPPDATA%\Arma 3\arma3_YYYYMMDD_HHMMSS.rpt`
- Используйте поиск по ключевым словам: `ERROR`, `WARNING`, название модуля

## Что дальше?

- ➡️ [Отладка](05_DEBUGGING.md) - инструменты и техники отладки
- ➡️ [Особенности синтаксиса](03_SYNTAX_GUIDE.md) - синтаксические особенности
- ➡️ [Модульная система](04_MODULE_SYSTEM.md) - работа с модулями

