# Типичные проблемы и их решения

Этот документ содержит описание типичных проблем, возникающих при разработке и поддержке проекта, а также способы их решения.

## Runtime ошибки

В Платформе ошибки времени выполнения имеют специфический формат. Проект использует модуль `ScriptErrorHandler` для автоматического перехвата и обработки ошибок. При возникновении ошибки отображается message box с подробной информацией, включая стектрейс.

**См. также:** [Отладка и диагностика - Runtime ошибки](05_DEBUGGING.md#runtime-ошибки) для полного списка типов ошибок.

### Generic Error in Expression

**Симптомы:**
- Ошибка "Generic Error in Expression" при выполнении команды
- Неожиданное поведение при вызове функций

**Причины:**
1. **Неправильный тип аргумента команды:**
   - Передан аргумент неверного типа
   - **Пример:** `systemChat 10` (ожидается строка, передано число)

2. **Неправильное окружение выполнения:**
   - Команда, требующая scheduled окружения, вызвана в unscheduled окружении
   - **Пример:** `sleep 10` (вызвано вне thread (scheduled окружения))

**Решение:**
```sqf
// Проверяйте типы аргументов перед вызовом команд
if (not_equalTypes(_message, "")) exitWith {
    errorformat("MyModule: systemChat expects string, got %1", typeName _message);
};
systemChat _message;

// Используйте spawn для команд, требующих scheduled окружения
if (needScheduled) then {
    private _thdCode = {
        sleep 10
        // код, требующий scheduled окружения
    };
    threadStart(threadNew(_thdCode)); // используется из thread.hpp
};
```

**Профилактика:**
- Проверяйте типы аргументов перед передачей в команды
- Используйте `not_equalTypes()` для проверки типов

### Zero Divisor

**Симптомы:**
- Ошибка "Zero Divisor" при выполнении операции
- Неожиданное поведение при работе с массивами или числами

**Причины:**
1. **Деление на ноль:**
   - Попытка разделить число на 0
   - **Пример:** `10 / 0`

2. **Выход за границы массива:**
   - Попытка доступа к несуществующему индексу массива
   - **Пример:** `[1,2,3] select 20`

**Решение:**
```sqf
// Всегда проверяйте делитель перед делением
if (_divisor != 0) then {
    private _result = _dividend / _divisor;
} else {
    error("MyModule: Division by zero");
};

// Всегда проверяйте размер массива перед доступом
if (count _array > _index) then {
    private _value = _array select _index;
} else {
    errorformat("MyModule: Array index %1 out of range (array size: %2)", _index, count _array);
};

// Используйте array_exists() для проверки существования элемента
if (array_exists(_array, _item)) then {
    // элемент существует
};
```

**Профилактика:**
- Всегда проверяйте делитель перед делением
- Используйте проверки размера массива перед доступом
- Используйте безопасные функции работы с массивами

### Attempt to override final function

**Симптомы:**
- Ошибка "Attempt to override final function" при попытке переопределить функцию
- Функция не может быть изменена

**Причины:**
- Попытка переопределить функцию, помеченную как `compileFinal`
- **Пример:** `BIS_fnc_endMission = {systemChat "Trying to do bad things"}`

**Решение:**
- Не пытайтесь переопределять функции, помеченные как `compileFinal`
- Используйте альтернативные подходы (обертки, модификаторы и т.д.)
- Проверьте документацию функции перед попыткой переопределения

**Профилактика:**
- Избегайте переопределения системных функций
- Используйте паттерны проектирования (декораторы, адаптеры) вместо прямого переопределения

### getVariable called on null object/group

**Симптомы:**
- Ошибка "getVariable called on null object" или "getVariable called on null group" (только в Debug режиме)
- Неожиданное поведение при работе с объектами

**Причины:**
- `getVariable` вызван на null объекте или группе
- **Пример:** `objNull getVariable "varname"` или `grpNull getVariable "varname"`

**Решение:**
```sqf
// Всегда проверяйте объект перед использованием getVariable
if (!isNullReference(_obj)) then {
    private _value = _obj getVariable "varname";
} else {
    errorformat("MyModule: Object is null");
};

// Используйте valid() для проверки объектов OOP системы
if (valid(_obj)) then {
    private _value = getVar(_obj,fieldName);
} else {
    errorformat("MyModule: Object is invalid");
};
```

**Профилактика:**
- Всегда проверяйте объекты на null перед использованием
- Используйте `valid()` для проверки объектов OOP системы
- Используйте `isNullVar()` для проверки переменных

### Serialization of Control variables is not implemented

**Симптомы:**
- Ошибка "Serialization of Control variables is not implemented" при сохранении миссии
- Проблемы с сохранением состояния UI

**Причины:**
- Переменные Control сохранены в `missionNamespace`
- Скрипт, использующий переменные Control, не выполнил `disableSerialization` перед использованием
- **Пример:** `cant_put_that_here = allControls (allDisplays # 0)`

**Решение:**
```sqf
// Храните Control переменные внутри массивов, ref-ов, векторов или структур.
myControlVar = [_control];
```

**Профилактика:**
- Документируйте использование Control переменных в коде

### Работа с null значениями

**Особенности работы с null значениями в SQF:**
- `if (null) then {} else {}` - обе ветки никогда не выполнятся (см. [Работа с null значениями](../Project/03_SYNTAX_GUIDE.md#работа-с-null-nil-значениями))
- `_array pushBack null` - null значение не будет добавлено, используйте `_array append [null]`
- Всегда проверяйте значения на null перед использованием в операциях

**Решение:**
```sqf
// Используйте isNullVar() для проверки переменных
if (isNullVar(_myVar)) then {
    _myVar = defaultValue;
};

// Используйте defIsNull() для значений по умолчанию
private _value = defIsNull(_param, defaultValue);

// Используйте valid() для проверки объектов
if (!valid(_obj)) exitWith {
    error("MyModule: Object is invalid");
};

// Используйте equalTypes() для сравнения типов
if (equalTypes(_obj1, _obj2)) then {
    // объекты одного типа
};
```

**Профилактика:**
- Всегда проверяйте типы данных перед использованием
- Используйте типизированные макросы (`var_num`, `var_str`, и т.д.)

## Проблемы загрузки модулей

### Модуль не загружается

**Симптомы:**
- Модуль не инициализируется
- Функции модуля недоступны
- Ошибки компиляции при загрузке модуля

**Причины:**
- Модуль не зарегистрирован в загрузчике
- Синтаксические ошибки в модуле
- Зависимости модуля не загружены

**Решение:**
1. Проверьте регистрацию модуля:
   - Для host: добавьте в `host/init.sqf` через `loadFile()`
   - Для client: добавьте в `client/loader.hpp` через `importClient()`
   - Для editor: добавьте в `Editor/Editor_init.sqf` через `componentInit()`

2. Проверьте синтаксис модуля:
   - Убедитесь, что файл `*_init.sqf` существует
   - Проверьте наличие синтаксических ошибок

3. Проверьте зависимости:
   - Убедитесь, что все зависимости загружены до модуля
   - Проверьте порядок загрузки модулей

**Профилактика:**
- Документируйте зависимости модуля
- Следуйте порядку загрузки, указанному в документации
- Проверяйте логи при загрузке модулей

### Неправильный порядок загрузки модулей

**Симптомы:**
- Ошибки "undefined variable" или "Cannot call (nil value)"
- Модуль пытается использовать функции другого модуля, который еще не загружен

**Причины:**
- Модуль загружается раньше своих зависимостей
- Нарушен порядок загрузки, указанный в документации

**Решение:**
1. Проверьте зависимости модуля
2. Переместите модуль в правильное место в загрузчике:
   - В `host/init.sqf` модули загружаются последовательно
   - В `client/loader.hpp` порядок определяется порядком `importClient()`

3. Убедитесь, что базовые системы загружены первыми:
   - `engine.hpp` должен быть включен до использования макросов
   - OOP engine должен быть загружен до использования классов
   - `Networking` должен быть загружен до использования RPC

**Профилактика:**
- Всегда документируйте зависимости модуля
- Следуйте порядку загрузки из документации
- Комментируйте причины порядка загрузки в коде

### Циклические зависимости

**Симптомы:**
- Модули зависят друг от друга циклически
- Невозможно определить правильный порядок загрузки

**Причины:**
- Плохое разделение ответственности модулей
- Нарушение принципа модульности

**Решение:**
1. Выявите циклическую зависимость
2. Вынесите общий функционал в отдельный модуль или `CommonComponents/`
3. Пересмотрите архитектуру модулей

**Профилактика:**
- Избегайте циклических зависимостей на этапе проектирования
- Используйте `CommonComponents/` для общего функционала
- Разделяйте ответственность модулей четко

## Проблемы производительности

### Медленные операции в циклах

**Симптомы:**
- Задержки при выполнении кода
- Низкий FPS во время выполнения определенных операций

**Причины:**
- Дорогие операции выполняются в цикле
- Неоптимальные алгоритмы

**Решение:**
```sqf
// Избегайте создания объектов в цикле
private _processor = new(MyClass);
{
    callFunc(_processor,process, [_x]);
} forEach _largeArray;
delete(_processor);

// Кэшируйте результаты вычислений
private _cachedValue = call expensiveCalculation;
{
    [_cachedValue] call useValue;
} forEach _array;
```

**Профилактика:**
- Профилируйте код для выявления узких мест
- Избегайте создания объектов в циклах
- Кэшируйте результаты дорогих вычислений

### Утечки памяти

**Симптомы:**
- Постепенное увеличение использования памяти
- Производительность снижается со временем

**Причины:**
- Объекты не удаляются после использования
- Обновления (updates) не останавливаются

**Решение:**
```sqf
// Всегда удаляйте объекты после использования
{
    private _obj = new(MyClass);
    // использование объекта
    delete(_obj);
} forEach _array;

// Останавливайте updates при удалении объекта
func(destructor)
{
    objParams();
    if (!isNullVar(_updateHandle)) then {
        stopUpdate(_updateHandle);
    };
};
```

**Профилактика:**
- Всегда удаляйте объекты после использования
- Используйте `autoref` для автоматической очистки ссылок
- Останавливайте updates и event handlers при удалении объектов

### Слишком частые сетевые запросы

**Симптомы:**
- Высокая сетевая нагрузка
- Задержки при сетевых операциях

**Причины:**
- RPC вызовы выполняются слишком часто
- Отсутствие кэширования сетевых данных

**Решение:**
- Кэшируйте результаты сетевых запросов
- Используйте батчинг для множественных запросов
- Оптимизируйте частоту обновлений сетевых систем (NOEngine, синхронизация данных, RPC)

**Профилактика:**
- Минимизируйте количество RPC вызовов
- Используйте эффективные протоколы синхронизации
- Кэшируйте сетевые данные на клиенте

## Отладка OOP системы

### Объект не создается

**Симптомы:**
- `new(MyClass)` возвращает null или invalid объект
- Ошибки при попытке использовать объект

**Причины:**
- Класс не был загружен или не существует
- Ошибка в конструкторе класса
- Проблемы с OOP engine

**Решение:**
```sqf
// Проверяйте результат создания объекта
private _obj = new(MyClass);
if (!valid(_obj)) exitWith {
    error("MyModule: Failed to create MyClass object");
};

// Проверяйте, что класс существует
if (!isImplementClass("MyClass")) exitWith {
    error("MyModule: Class MyClass is not loaded");
};
```

**Профилактика:**
- Убедитесь, что класс объявлен и загружен
- Проверяйте валидность объектов после создания
- Используйте `valid()` для проверки объектов

### Метод не вызывается или вызывается неправильно

**Симптомы:**
- Метод не выполняется
- Ошибки при вызове метода
- Неправильные параметры метода

**Причины:**
- Метод не определен в классе
- Неправильное использование макросов вызова
- Проблемы с параметрами метода

**Решение:**
```sqf
// Проверяйте существование метода перед вызовом
if (!isImplementFunc(_obj,myMethod)) exitWith {
    error("MyModule: Method myMethod not found");
};
callFunc(_obj,myMethod);

// Убедитесь, что используете правильный макрос
callSelf(myMethod);                    // Без параметров
callSelfParams(myMethod, [param1 arg param2]); // С параметрами

// Проверяйте параметры метода
func(myMethod)
{
    objParams_2(_param1, _param2);
    if (isNullVar(_param1)) exitWith {
        error("MyClass: myMethod: param1 is required");
    };
    // остальной код метода
};
```

**Профилактика:**
- Используйте правильные макросы для вызова методов
- Всегда используйте `objParams()` в методах
- Проверяйте параметры методов перед использованием

### Проблемы с наследованием

**Симптомы:**
- Метод родительского класса не вызывается
- Поля родительского класса недоступны
- Ошибки при вызове `super()`

**Причины:**
- Неправильное использование наследования
- Ошибки в вызове базового метода

**Решение:**
```sqf
// Используйте super() для вызова базового метода
class(ChildClass) extends(ParentClass)
    func(overrideMethod)
    {
        objParams();
        // Вызов базового метода
        private _result = super();
        // Дополнительная логика
        _result
    };
endclass

// Проверяйте наследование
if (isTypeOf(_obj,ParentClass)) then {
    // объект является экземпляром ParentClass или его наследника
};
```

**Профилактика:**
- Используйте `super()` для вызова базовых методов
- Проверяйте типы объектов при работе с наследованием
- Документируйте иерархию классов

### Проблемы с полями объекта

**Симптомы:**
- Поле недоступно или имеет неправильное значение
- Ошибки при доступе к полю

**Причины:**
- Поле не было инициализировано
- Неправильное имя поля
- Проблемы с областью видимости

**Решение:**
```sqf
class(MyClass) extends(BaseClass)
    // Объявление полей должно быть в теле класса, не внутри методов
    var(myField, defaultValue);  // Правильно: объявление в теле класса
    
    func(constructor)
    {
        objParams();
        // В конструкторе можно установить значение для уже объявленного поля
        setSelf(myField, defaultValue);  // Правильно: установка значения уже объявленного поля
    };
endclass

// Проверяйте существование поля
if (isImplementVar(_obj,myField)) then {
    private _value = getVar(_obj,myField);
};

// Используйте правильные макросы для работы с полями
getSelf(myField);              // Внутри метода класса
getVar(_obj,myField);         // Извне класса
```

**Важно:** Все поля класса должны быть объявлены через `var()` в теле класса. `var()` и `func()` могут использоваться **только в теле класса** (между `class()` и `endclass`), но **не внутри методов**. Подробнее см. [Стандарты кодирования - Динамическое создание полей в конструкторе](09_CODING_STANDARDS.md#динамическое-создание-полей-в-конструкторе).

**Профилактика:**
- Всегда инициализируйте поля в конструкторе
- Используйте правильные макросы для доступа к полям
- Проверяйте существование полей перед использованием

## Проблемы редактора

### Редактор не загружается

**Симптомы:**
- Редактор не запускается
- Ошибки при загрузке редактора
- Модули редактора не загружаются

**Причины:**
- Мод @EditorContent не установлен
- BattlEye включен (должен быть отключен)
- Ошибки в коде редактора

**Решение:**
1. Убедитесь, что мод @EditorContent установлен:
   - Запустите `RBuilder/DEPLOY.bat` или `rb deploy -editor`
   - Проверьте наличие папки `@EditorContent` в директории Arma 3

2. Отключите BattlEye в настройках лаунчера

3. Проверьте логи на ошибки загрузки

**Профилактика:**
- Всегда проверяйте установку @EditorContent после обновления
- Документируйте требования для работы редактора

### Ошибки компиляции в редакторе

**Симптомы:**
- Ошибки компиляции при загрузке редактора
- Модули редактора не компилируются

**Причины:**
- Синтаксические ошибки в коде редактора
- Проблемы с зависимостями
- Ошибки в компонентах редактора

**Решение:**
1. Проверьте синтаксис кода редактора
2. Убедитесь, что все зависимости загружены
3. Проверьте логи редактора на детали ошибок

**Профилактика:**
- Проверяйте синтаксис перед коммитом
- Тестируйте редактор после изменений
- Используйте линтеры и валидаторы кода

### Проблемы с визуальными компонентами

**Симптомы:**
- Визуальные компоненты не отображаются
- Ошибки при работе с 3D объектами в редакторе

**Причины:**
- Проблемы с загрузкой моделей
- Ошибки в коде визуальных компонентов
- Проблемы с синхронизацией состояния

**Решение:**
- Проверьте наличие моделей и их пути
- Проверьте логи на ошибки загрузки моделей
- Убедитесь, что визуальные компоненты правильно инициализированы

**Профилактика:**
- Тестируйте визуальные компоненты после изменений
- Документируйте требования к моделям и ресурсам

## Общие рекомендации по отладке

### Использование логирования

```sqf
// Используйте разные уровни логирования
log("Информационное сообщение");
warning("Предупреждение");
error("Ошибка");

// Используйте трассировку для отладки (только в DEBUG)
trace("Точка выполнения");
traceformat("Debug: Значение: %1", _value);
```

### Использование breakpoints

```sqf
#ifdef __TRACE__ENABLED
breakpoint_setfile("MyModule.sqf");
breakpoint("Достигнута точка останова");
#endif
```

**Примечание:** Макрос `breakpoint()` не останавливает выполнение кода - он только логирует сообщение с информацией о номере строки и файле. Выполнение продолжается после вызова.

### Проверка состояния объектов

```sqf
// Проверка валидности объекта
if (!valid(_obj)) exitWith {
    error("MyModule: Object is invalid");
};

// Получение всех полей объекта (для отладки)
private _fields = (this getVariable PROTOTYPE_VAR_NAME) getVariable "__allfields";
logformat("Debug: Object fields: %1", _fields);
```

### Работа с логами

- Логи сервера: `%LOCALAPPDATA%\Arma 3\arma3server_YYYYMMDD_HHMMSS.rpt`
- Логи клиента: `%LOCALAPPDATA%\Arma 3\arma3_YYYYMMDD_HHMMSS.rpt`
- Используйте поиск по ключевым словам: `ERROR`, `WARNING`, название модуля

## Типичные ошибки новичков

Этот раздел содержит наиболее распространенные ошибки, которые допускают новые разработчики при работе с проектом.

### Ошибка: использование `logformat` с несколькими аргументами напрямую

**Проблема:**
```sqf
// ❌ НЕПРАВИЛЬНО
logformat("Values: %1, %2", value1, value2);  // ОШИБКА: logformat принимает только 2 аргумента!
```

**Решение:**
```sqf
// ✅ ПРАВИЛЬНО - используйте arg для объединения значений
logformat("Values: %1, %2", value1 arg value2);
```

**Объяснение:** Макрос `logformat` принимает только 2 аргумента: формат-строку и массив значений. Для нескольких значений используйте макрос `arg` для объединения их в единый аргумент.

### Ошибка: попытка использовать `getSelf()` в `getterconst_func`

**Проблема:**
```sqf
// ❌ НЕПРАВИЛЬНО
class(MyClass) extends(BaseClass)
    getterconst_func(getValue, getSelf(value));  // ОШИБКА: this не определен!
endclass
```

**Решение:**
```sqf
// ✅ ПРАВИЛЬНО - используйте getter_func для доступа к полям объекта
class(MyClass) extends(BaseClass)
    var(value, 0);
    getter_func(getValue, getSelf(value));  // Корректно - getter_func имеет доступ к this
endclass

// Или используйте getterconst_func только для константных значений
getterconst_func(isItem, false);  // Корректно - константное значение
```

**Объяснение:** `getterconst_func` выполняется в контексте определения класса, а не объекта, поэтому не имеет доступа к `this`. Используйте его только для константных значений, одинаковых для всех экземпляров класса.

### Ошибка: использование макросов OOP в CommonComponents

**Проблема:**
```sqf
// ❌ НЕПРАВИЛЬНО - в CommonComponents/MyModule.sqf
myModule_process = {
    params ["_obj"];
    callFunc(_obj,doSomething); // ОШИБКА: макрос callFunc не определен!
    getVar(_obj,someField);     // ОШИБКА: макрос getVar не определен!
};
```

**Решение:**
```sqf
// ✅ ПРАВИЛЬНО - CommonComponents не должны использовать OOP систему
// Используйте прямую работу с объектами или передавайте данные через параметры
myModule_process = {
    params ["_data"];
    // работа с данными без OOP макросов
};
```

**Объяснение:** CommonComponents выполняются и на сервере, и на клиенте, но OOP система (`oop.hpp`) доступна только на сервере. Поэтому все макросы из `oop.hpp` не могут использоваться в CommonComponents.

### Ошибка: пробелы в макросах OOP (после запятых)

**Проблема:**
```sqf
// ❌ НЕПРАВИЛЬНО - пробелы до или после запятой
callFuncParams(this, printData , [1 arg 2]);  // ОШИБКА: обращение к методу "printData "
callFuncParams(this, printData, [1 arg 2]);   // ОШИБКА: обращение к методу " printData"
getVar(obj, myField );  // ОШИБКА: обращение к полю "myField "
```

**Решение:**
```sqf
// ✅ ПРАВИЛЬНО - без пробелов до и после запятой
callFuncParams(this,printData, [1 arg 2]);  // Корректно: обращение к методу "printData"
getVar(obj,myField);  // Корректно: обращение к полю "myField"
setVar(obj,value,10);  // Корректно: обращение к полю "value"
```

**Объяснение:** В макросах OOP второй аргумент (имя метода/поля) не должен содержать пробелов перед запятой или после. Макрос использует строкификацию, которая захватывает все символы между запятыми, включая пробелы.

### Ошибка: смешение регистра в структурах

**Проблема:**
```sqf
// ❌ НЕПРАВИЛЬНО - структуры РЕГИСТРОЗАВИСИМЫ!
struct(MyStruct)
    def(Value) 0;  // Поле с именем "Value"
endstruct

private _struct = struct_new(MyStruct);
_struct getv(value);  // ОШИБКА: поле "value" не существует, нужно "Value"!
```

**Решение:**
```sqf
// ✅ ПРАВИЛЬНО - всегда используйте точный регистр при работе со структурами
struct(MyStruct)
    def(Value) 0;  // Поле с именем "Value"
endstruct

private _struct = struct_new(MyStruct);
_struct getv(Value);  // Корректно - точное соответствие регистру
_struct setv(Value, 10);  // Корректно
```

**Объяснение:** В отличие от OOP системы, где имена полей и методов НЕ регистрозависимы, в структурах имена полей и методов РЕГИСТРОЗАВИСИМЫ. Всегда используйте точный регистр, как объявлено в структуре.

### Ошибка: попытка использовать `autoref` для классов, не наследованных от `ManagedObject`

**Проблема:**
```sqf
// ❌ НЕПРАВИЛЬНО - класс не наследуется от ManagedObject
class(MyClass) extends(object)  // object не наследуется от ManagedObject
    autoref var(ref, nullPtr);  // ОШИБКА: autoref не работает для этого класса!
endclass
```

**Решение:**
```sqf
// ✅ ПРАВИЛЬНО - используйте autoref только для классов, наследованных от ManagedObject
class(MyClass) extends(Item)  // Item наследуется от GameObject -> ManagedObject
    autoref var(ref, nullPtr);  // Корректно - autoref доступен
endclass

// Или используйте явную очистку в деструкторе
class(MyClass) extends(object)
    var(ref, nullPtr);
    
    func(destructor)
    {
        objParams();
        if (!isNullVar(getSelf(ref))) then {
            delete(getSelf(ref));
        };
    };
endclass
```

**Объяснение:** `autoref` работает только для классов, унаследованных от `ManagedObject`. В проекте все игровые объекты (`GameObject`, `Item`, `IStruct`, `Decor`, `BasicMob`, `Mob` и т.д.) наследуются от `ManagedObject`, поэтому для них `autoref` доступен. Если класс не наследуется от `ManagedObject`, используйте явную очистку в деструкторе.

## Что дальше?

- ➡️ [Отладка](05_DEBUGGING.md) - инструменты и техники отладки
- ➡️ [Особенности синтаксиса](03_SYNTAX_GUIDE.md) - синтаксические особенности
- ➡️ [Модульная система](04_MODULE_SYSTEM.md) - работа с модулями

